From abbff5856ae42c1c14e6fa1d32e3e0380bc047bf Mon Sep 17 00:00:00 2001
From: micbis <michele.bisogno.ct@renesas.com>
Date: Fri, 2 Sep 2022 10:38:42 +0200
Subject: [PATCH 1/1] SD boot support

---
 plat/renesas/rz/common/drivers/io/io_sddrv.c  | 205 ++++
 plat/renesas/rz/common/drivers/io/io_sddrv.h  |  13 +
 .../rz/common/drivers/sd/boot_common.h        | 195 ++++
 plat/renesas/rz/common/drivers/sd/boot_esd.h  |  55 +
 .../rz/common/drivers/sd/boot_esd_if.h        |  64 ++
 .../rz/common/drivers/sd/boot_esddev.c        | 437 ++++++++
 .../rz/common/drivers/sd/cpg_iodefine.h       | 186 ++++
 plat/renesas/rz/common/drivers/sd/esdif.h     | 189 ++++
 .../renesas/rz/common/drivers/sd/r_typedefs.h |  56 +
 plat/renesas/rz/common/drivers/sd/sd.h        | 642 ++++++++++++
 plat/renesas/rz/common/drivers/sd/sd_cd.c     | 160 +++
 plat/renesas/rz/common/drivers/sd/sd_cmd.c    | 802 ++++++++++++++
 plat/renesas/rz/common/drivers/sd/sd_init.c   | 290 ++++++
 plat/renesas/rz/common/drivers/sd/sd_int.c    | 212 ++++
 plat/renesas/rz/common/drivers/sd/sd_main.c   | 146 +++
 plat/renesas/rz/common/drivers/sd/sd_mount.c  | 977 ++++++++++++++++++
 plat/renesas/rz/common/drivers/sd/sd_read.c   | 596 +++++++++++
 plat/renesas/rz/common/drivers/sd/sd_trns.c   | 147 +++
 plat/renesas/rz/common/drivers/sd/sd_util.c   | 400 +++++++
 plat/renesas/rz/common/drivers/sd/sys_sel.h   |  57 +
 plat/renesas/rz/common/drivers/sd/ut_define.h |  66 ++
 plat/renesas/rz/common/include/rzg2l_def.h    |   3 +
 plat/renesas/rz/common/plat_storage.c         |  88 +-
 plat/renesas/rz/common/rz_common.mk           |  19 +-
 24 files changed, 5996 insertions(+), 9 deletions(-)
 create mode 100644 plat/renesas/rz/common/drivers/io/io_sddrv.c
 create mode 100644 plat/renesas/rz/common/drivers/io/io_sddrv.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/boot_common.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/boot_esd.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/boot_esd_if.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/boot_esddev.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/cpg_iodefine.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/esdif.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/r_typedefs.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_cd.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_cmd.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_init.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_int.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_main.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_mount.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_read.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_trns.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sd_util.c
 create mode 100644 plat/renesas/rz/common/drivers/sd/sys_sel.h
 create mode 100644 plat/renesas/rz/common/drivers/sd/ut_define.h

diff --git a/plat/renesas/rz/common/drivers/io/io_sddrv.c b/plat/renesas/rz/common/drivers/io/io_sddrv.c
new file mode 100644
index 000000000..fd681e640
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/io/io_sddrv.c
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <string.h>
+
+#include <common/debug.h>
+#include <drivers/io/io_driver.h>
+#include <drivers/io/io_storage.h>
+
+#include "emmc_config.h"
+#include "emmc_def.h"
+#include "emmc_hal.h"
+#include "emmc_std.h"
+
+#include "io_common.h"
+#include "io_private.h"
+
+#include "sd.h"
+#include "io_sddrv.h"
+#include "sys_sel.h"
+#include "esdif.h"
+
+
+static int32_t sddrv_dev_open(const uintptr_t spec __attribute__ ((unused)),
+				io_dev_info_t **dev_info);
+static int32_t sddrv_dev_close(io_dev_info_t *dev_info);
+
+typedef struct {
+	uint32_t in_use;
+	uintptr_t base;
+	signed long long file_pos;
+	EMMC_PARTITION_ID partition;
+} file_state_t;
+
+static file_state_t current_file = { 0 };
+
+static io_type_t device_type_sddrv(void)
+{
+	return IO_TYPE_MEMMAP;
+}
+
+static int32_t sddrv_block_seek(io_entity_t *entity, int32_t mode,
+				  signed long long offset)
+{
+	if (mode != IO_SEEK_SET) {
+		return IO_FAIL;
+	}
+
+	((file_state_t *) entity->info)->file_pos = offset;
+
+	return IO_SUCCESS;
+}
+
+static int32_t sddrv_block_read(io_entity_t *entity, uintptr_t buffer,
+				  size_t length, size_t *length_read)
+{
+	file_state_t *fp = (file_state_t *) entity->info;
+	uint32_t first_sector, last_sector, sector_count = 0;
+	uint8_t sector_buf[EMMC_SECTOR_SIZE];
+	size_t buffer_offset = 0;
+	int32_t result = IO_SUCCESS;
+
+	first_sector = (fp->base + fp->file_pos) >> EMMC_SECTOR_SIZE_SHIFT;
+	last_sector = (fp->base + fp->file_pos + length -1 ) >> EMMC_SECTOR_SIZE_SHIFT;
+	sector_count = last_sector - first_sector + 1;
+
+	NOTICE("BL2: Load dst=0x%lx src=(p:%d)0x%llx(%d) len=0x%lx(%d)\n",
+			buffer,
+			fp->partition, (fp->base + fp->file_pos),
+			first_sector, length, sector_count);
+
+//	Temporarily disable DMA.
+//	if ((buffer + length - 1U) <= (uintptr_t)UINT32_MAX) {
+//		emmc_dma = LOADIMAGE_FLAGS_DMA_ENABLE;
+//	}
+
+    // first sector
+	uint32_t first_offset = (fp->base + fp->file_pos) % EMMC_SECTOR_SIZE;
+	if( 0 < first_offset ) {
+		memset(sector_buf, 0x00, EMMC_SECTOR_SIZE);
+		if(esd_read_sect((uint8_t*)sector_buf,
+			first_sector, 1) != SD_OK) {
+			result = IO_FAIL;
+			goto block_read_done;
+		}
+		else {
+			buffer_offset = EMMC_SECTOR_SIZE - first_offset;
+			buffer_offset = (length < buffer_offset) ? length : buffer_offset;
+
+			memcpy((uint8_t *)buffer, &sector_buf[first_offset], buffer_offset);
+
+			first_sector++;
+			sector_count--;
+		}
+	}
+
+	// last sector
+	uint32_t last_offset = (fp->base + fp->file_pos + length) % EMMC_SECTOR_SIZE;
+	if(0 < sector_count && 0 < last_offset) {
+		memset(sector_buf, 0x00, EMMC_SECTOR_SIZE);
+		if (esd_read_sect((uint8_t*)sector_buf,
+				last_sector, 1) != SD_OK) {
+			result = IO_FAIL;
+			goto block_read_done;
+		}
+		else {
+			memcpy((uint8_t *) buffer + (length - last_offset), &sector_buf[0], last_offset);
+			sector_count--;
+		}
+	}
+
+	// middle sector
+	if(0 < sector_count) {
+		if (esd_read_sect((uint8_t *)(buffer + buffer_offset),
+				first_sector, sector_count) != SD_OK) {
+			result = IO_FAIL;
+			goto block_read_done;
+		}
+	}
+
+	*length_read = length;
+	fp->file_pos += (signed long long)length;
+block_read_done:
+
+	return result;
+}
+
+static int32_t sddrv_block_open(io_dev_info_t *dev_info,
+				const uintptr_t spec, io_entity_t *entity)
+{
+	const io_drv_spec_t *block_spec = (io_drv_spec_t *) spec;
+
+	if (current_file.in_use != 0U) {
+		WARN("sd_block: Only one open spec at a time\n");
+		return IO_RESOURCES_EXHAUSTED;
+	}
+
+	current_file.base = block_spec->offset;
+	current_file.file_pos = 0;
+	current_file.in_use = 1;
+
+	current_file.partition = mmc_drv_obj.boot_partition_en;
+	NOTICE("BL2: SD boot from partition %d\n", current_file.partition);
+
+	entity->info = (uintptr_t) &current_file;
+
+	return IO_SUCCESS;
+}
+
+static int32_t sddrv_block_close(io_entity_t *entity)
+{
+	memset((void *)&current_file, 0, sizeof(current_file));
+	entity->info = 0U;
+
+	return IO_SUCCESS;
+}
+
+static const io_dev_funcs_t sddrv_dev_funcs = {
+	.type = &device_type_sddrv,
+	.open = &sddrv_block_open,
+	.seek = &sddrv_block_seek,
+	.size = NULL,
+	.read = &sddrv_block_read,
+	.write = NULL,
+	.close = &sddrv_block_close,
+	.dev_init = NULL,
+	.dev_close = &sddrv_dev_close
+};
+
+static const io_dev_info_t sddrv_dev_info = {
+	.funcs = &sddrv_dev_funcs,
+	.info = (uintptr_t) 0
+};
+
+static const io_dev_connector_t sddrv_dev_connector = {
+	&sddrv_dev_open,
+};
+
+static int32_t sddrv_dev_open(const uintptr_t spec __attribute__ ((unused)),
+				io_dev_info_t **dev_info)
+{
+	*dev_info = (io_dev_info_t *) &sddrv_dev_info;
+
+	return IO_SUCCESS;
+}
+
+static int32_t sddrv_dev_close(io_dev_info_t *dev_info)
+{
+	return IO_SUCCESS;
+}
+
+int32_t register_io_dev_sddrv(const io_dev_connector_t **dev_con)
+{
+	int32_t rc;
+
+	rc = io_register_device(&sddrv_dev_info);
+	if (rc == IO_SUCCESS) {
+		*dev_con = &sddrv_dev_connector;
+	}
+
+	return rc;
+}
diff --git a/plat/renesas/rz/common/drivers/io/io_sddrv.h b/plat/renesas/rz/common/drivers/io/io_sddrv.h
new file mode 100644
index 000000000..5485d9e01
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/io/io_sddrv.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef IO_SDDRV_H
+#define IO_SDDRV_H
+
+struct io_dev_connector;
+int32_t register_io_dev_sddrv(const io_dev_connector_t **connector);
+
+#endif /* IO_SDDRV_H */
diff --git a/plat/renesas/rz/common/drivers/sd/boot_common.h b/plat/renesas/rz/common/drivers/sd/boot_common.h
new file mode 100644
index 000000000..4a1096f26
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/boot_common.h
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : boot_common.h
+ * Version      : 1.0
+ * Description  : RZ/G2L Boot Program common header file.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef BOOTCOM_H
+#define BOOTCOM_H
+
+#define SHRINK_ROM      /* Shrink ROM size */
+
+#ifdef  SHRINK_ROM
+#define NOUSE_VARIABLE_ARGUMENTS
+#endif  /* SHRINK_ROM */
+
+/*------------ RAM load address -------------------------------*/
+#define BOOT_INFO_ADR               (0x000010000ul)     /* Boot information area */
+#define LOAD_ADDR                   (0x000012000ul)     /* Load address in internal RAM */
+#define BOOT_INFO_SIZE              (0x000000300ul)     /* Boot information area size */
+#define LOAD_ADDR_LIMIT             (0x00002F000ul)
+
+/*------------ Load size block in internal RAM ----------------*/
+#define LOAD_SIZE_BLOCK_SIZE        (0x00000200ul)      /* "Loader size block's" size */
+
+#define RAM_LSBLOCK_ADDR            ((uintptr_t) (LOAD_ADDR - LOAD_SIZE_BLOCK_SIZE))/* Address of load size block */
+#define RAM_LSBLOCK_DATA_SIZE_PTR   ((uint32_t *)(RAM_LSBLOCK_ADDR))            /* Pointer to loader size */
+#define RAM_LSBLOCK_SIGN_PTR        ((uint16_t *)(RAM_LSBLOCK_ADDR + 0x01FEul)) /* Pointer to signature */
+
+/*------------ Definitions of Return Value---------------------*/
+#define OK                          ( 0)                /* Successful operation */
+#define ERR                         (-1)                /* Fail                 */
+
+/* Add from eMMC boot*/
+/*------------ Loader program size -------------------------------*/
+#define D_BOOT_LOAD_SIZE_MAX        (LOAD_ADDR_LIMIT - LOAD_ADDR)   /* 0x00012000 ... 0x0002EFFF */
+
+/*------------ Definitions of Return Value ---------------------*/
+#define D_BOOT_OK                           (0l)                /* Successful operation */
+#define D_BOOT_ERR                          (-1l)               /* Fail                 */
+#define D_BOOT_SECU_ERR                     (-20l)              /* Fail w/verify        */
+
+#define D_BOOT_SECU_ERR_CHKSUM              (-21l)              /* Checksum error w/verify         */
+#define D_BOOT_SECU_ERR_SIZE                (-22l)              /* Program size error w/verify     */
+#define D_BOOT_SECU_ERR_MDR                 (-23l)              /* MDR register error w/verify     */
+
+/*------------ Definitions of boot type ---------------------*/
+#define D_BOOT_MODE_SECEN                   (0x00010000u)       /* Secure enable (standard/secure product)         */
+#define D_BOOT_MODE_MDCLKS                  (0x00001000u)       /* MD clock                                        */
+#define D_BOOT_MODE_DBGEN                   (0x00000200u)       /* Debug enable                                    */
+#define D_BOOT_MODE_COUHLD                  (0x00000100u)       /* CPU hold                                        */
+#define D_BOOT_MODE_ESD                     (0x00000000u)       /* eSD boot mode                                   */
+#define D_BOOT_MODE_EMMC18                  (0x00000001u)       /* eMMC boot 1.8V mode                             */
+#define D_BOOT_MODE_EMMC33                  (0x00000002u)       /* eMMC boot 3.3V mode                             */
+#define D_BOOT_MODE_SFLASH18                (0x00000003u)       /* Serial flash 1.8V boot mode                     */
+#define D_BOOT_MODE_SFLASH33                (0x00000004u)       /* Serial flash 3.3V boot mode                     */
+#define D_BOOT_MODE_SCIF                    (0x00000005u)       /* SCIF download boot mode                         */
+#define D_BOOT_MODE_BTMD_MSK                (0x00000007u)       /* Boot mode mask bit pattern                      */
+
+#define D_BOOT_MODE_SECBEN_MSK              (D_BOOT_MODE_SECEN | D_BOOT_MODE_BTMD_MSK)
+
+
+#define D_BOOT_MODE_TYPE_INFO               (0x00010007ul)      /* bit[16]:Secure enable, bit[2:0]:BTMD[2:0]  */
+#define D_BOOT_MODE_INIT_PTRN               (0xFFFFFFFFul)      /* Initial pattern */
+
+
+/*------------ Definitions of device ID ---------------------*/
+#define D_BOOT_DEVIDR_DEV_REV_MSK           (0xF0000000u)       /* Device revision mask bit pattern */
+#define D_BOOT_DEVIDR_DEV_ID_MSK            (0x0FFFFFFFu)       /* Device ID mask bit pattern */
+#define D_BOOT_DEVIDR_DEV_ID_RZG2L          (0x0841C447u)       /* Device ID specified RZ/G2L */
+
+/*------------ Definitions of CA55 core information ---------------------*/
+#define D_BOOT_PRR_CA55_1CPU_MSK            (0x00000001u)       /* CA55 core count mask bit pattern */
+#define D_BOOT_PRR_CA55_SINGLE              (0x00000001u)       /* CA55 single core */
+#define D_BOOT_PRR_CA55_DUAL                (0x00000000u)       /* CA55 dual   core */
+/*------------ Definitions of CM33 core information ---------------------*/
+#define D_BOOT_PRR_CM33_DIS_MSK             (0x00000010u)       /* CM33 core implement mask bit pattern */
+#define D_BOOT_PRR_CA33_DIS                 (0x00000010u)       /* CM33 core not implement */
+#define D_BOOT_PRR_CA33_ENA                 (0x00000000u)       /* CM33 core implement */
+/*------------ Definitions of GPU information ---------------------*/
+#define D_BOOT_PRR_GPU_DIS_MSK              (0x00000010u)       /* GPU implement mask bit pattern */
+#define D_BOOT_PRR_GPU_DIS                  (0x00000010u)       /* Mali-G31 not implement */
+#define D_BOOT_PRR_GPU_ENA                  (0x00000000u)       /* Mali-G31 implement */
+
+/*------------ Definitions of secure boot mode en/dis ---------------------*/
+#define D_BOOT_OTPSECENR_SECEN_MSK          (0x00000001u)       /* Secure boot mask bit pattern      */
+#define D_BOOT_OTPSECENR_SECEN_ENA          (0x00000001u)       /* Secure boot mode (secure enable)  */
+#define D_BOOT_OTPSECENR_SECEN_DIS          (0x00000000u)       /* Normal boot mode (secure disable) */
+
+/*------------ Definitions of secure boot device en/dis ---------------------*/
+/*------------ eSD information ---------------------*/
+#define D_BOOT_OTPSECMDR_SD_MSK             (0x00000001u)       /* eSD secure boot mask bit pattern */
+#define D_BOOT_OTPSECMDR_SD_ENA             (0x00000001u)       /* eSD secure boot enable  */
+#define D_BOOT_OTPSECMDR_SD_DIS             (0x00000000u)       /* eSD secure boot disable */
+/*------------ eSD information ---------------------*/
+#define D_BOOT_OTPSECMDR_EMMC18_MSK         (0x00000002u)       /* eMMC 1.8V secure boot mask bit pattern */
+#define D_BOOT_OTPSECMDR_EMMC18_ENA         (0x00000002u)       /* eMMC 1.8V secure boot enable  */
+#define D_BOOT_OTPSECMDR_EMMC18_DIS         (0x00000000u)       /* eMMC 1.8V secure boot disable */
+#define D_BOOT_OTPSECMDR_EMMC33_MSK         (0x00000004u)       /* eMMC 3.3V secure boot mask bit pattern */
+#define D_BOOT_OTPSECMDR_EMMC33_ENA         (0x00000004u)       /* eMMC 3.3V secure boot enable  */
+#define D_BOOT_OTPSECMDR_EMMC33_DIS         (0x00000000u)       /* eMMC 3.3V secure boot disable */
+/*------------ SPI multi information ---------------------*/
+#define D_BOOT_OTPSECMDR_SPI18_MSK          (0x00000008u)       /* sFlash 1.8V secure boot mask bit pattern */
+#define D_BOOT_OTPSECMDR_SPI18_ENA          (0x00000008u)       /* sFlash 1.8V secure boot enable  */
+#define D_BOOT_OTPSECMDR_SPI18_DIS          (0x00000000u)       /* sFlash 1.8V secure boot disable */
+#define D_BOOT_OTPSECMDR_SPI33_MSK          (0x00000010u)       /* sFlash 3.3V secure boot mask bit pattern */
+#define D_BOOT_OTPSECMDR_SPI33_ENA          (0x00000010u)       /* sFlash 3.3V secure boot enable  */
+#define D_BOOT_OTPSECMDR_SPI33_DIS          (0x00000000u)       /* sFlash 3.3V secure boot disable */
+
+
+/*------------ Definitions of JTAG certification mode ---------------------*/
+#define D_BOOT_OTPJAMR_JAM_MSK              (0x00000003u)       /* JTAG certification mode mask bit pattern */
+
+/*------------ Definitions of boot frequency ---------------------*/
+#define D_BOOT_OTPJCORER_FREQ_MSK           (0x00000003u)       /* Boot frequency mask bit pattern on CA55 core0 */
+
+/*------------ Definitions of driving power ---------------------*/
+#define D_BOOT_OTPPOC_DRV_ESD_MSK           (0x00000003u)       /* Driving power mask bit pattern for eSD */
+#define D_BOOT_OTPPOC_DRV_EMMC18_MSK        (0x0000000Cu)       /* Driving power mask bit pattern for eMMC 1.8V */
+#define D_BOOT_OTPPOC_DRV_EMMC33_MSK        (0x00000030u)       /* Driving power mask bit pattern for eMMC 3.3V */
+#define D_BOOT_OTPPOC_DRV_SPI18_MSK         (0x000000C0u)       /* Driving power mask bit pattern for SPI Multi 1.8V */
+#define D_BOOT_OTPPOC_DRV_SPI33_MSK         (0x00000300u)       /* Driving power mask bit pattern for SPI Multi 3.3V */
+#define D_BOOT_OTPPOC_DRV_SCIF_MSK          (0x00000C00u)       /* Driving power mask bit pattern for SCIF */
+
+#define D_BOOT_OTPPOC_DRV_MSK               (0x00000003u)       /* Driving power mask bit pattern */
+
+
+#define VOLTAGE18                           (0U)
+#define VOLTAGE33                           (1U)
+
+/*------------ RAM load address -------------------------------*/
+#define D_BOOT_LOAD_ADDR        ((volatile uint32_t *)(LOAD_ADDR))          /* Loader Program (eSD/eMMC) Top address  */
+#define D_BOOT_BOOT_RESULT      (BOOT_INFO_ADR + 0x0002ul)
+#define D_BOOT_LOG_INFO_BASE    (BOOT_INFO_ADR + 0x0004ul)                  /* Boot Log start address */
+
+#define D_BOOT_SB_FUNC_RESULT   (BOOT_INFO_ADR + 0x0018ul)
+#define D_BOOT_MB_FUNC_RESULT   (BOOT_INFO_ADR + 0x001Cul)
+#define D_BOOT_MEASURED_BOOT    (BOOT_INFO_ADR + 0x0020ul)
+
+/*------------ Secure boot load definition -------------------------------*/
+#define D_BOOT_KEY_CERT_ADDR        ((volatile uint32_t *)((uint32_t)D_BOOT_LOAD_ADDR))
+#define D_BOOT_KEY_CERT_LEN_MAX     (1024)
+#define D_BOOT_CODE_CERT_ADDR       ((volatile uint32_t *)((uint32_t)D_BOOT_LOAD_ADDR + 1024))
+#define D_BOOT_CODE_CERT_LEN_MAX    (1024)
+
+/*------------ Definitions of boot mode information ---------------------*/
+#define D_BOOT_MODE_INFO_NRM_ESD            (0x0000u)           /* eSD                boot mode, normal mode    */
+#define D_BOOT_MODE_INFO_NRM_EMMC18         (0x0001u)           /* eMMC(1.8V)         boot mode, normal mode    */
+#define D_BOOT_MODE_INFO_NRM_EMMC33         (0x0002u)           /* eMMC(3.3V)         boot mode, normal mode    */
+#define D_BOOT_MODE_INFO_NRM_SFLSH18        (0x0003u)           /* Serial Flash(1.8V) boot mode, normal mode    */
+#define D_BOOT_MODE_INFO_NRM_SFLSH33        (0x0004u)           /* Serial Flash(1.8V) boot mode, normal mode    */
+#define D_BOOT_MODE_INFO_NRM_SCIF           (0x0005u)           /* SCIF download      boot mode, normal mode    */
+#define D_BOOT_MODE_INFO_SECURE             (0x0010u)           /*             Secure boot mode, normal mode    */
+
+#define D_BOOT_MODE_INFO_SEC_ESD            (D_BOOT_MODE_INFO_SECURE | D_BOOT_MODE_INFO_NRM_ESD)
+#define D_BOOT_MODE_INFO_SEC_EMMC18         (D_BOOT_MODE_INFO_SECURE | D_BOOT_MODE_INFO_NRM_EMMC18)
+#define D_BOOT_MODE_INFO_SEC_EMMC33         (D_BOOT_MODE_INFO_SECURE | D_BOOT_MODE_INFO_NRM_EMMC33)
+#define D_BOOT_MODE_INFO_SEC_SFLSH18        (D_BOOT_MODE_INFO_SECURE | D_BOOT_MODE_INFO_NRM_SFLSH18)
+#define D_BOOT_MODE_INFO_SEC_SFLSH33        (D_BOOT_MODE_INFO_SECURE | D_BOOT_MODE_INFO_NRM_SFLSH33)
+#define D_BOOT_MODE_INFO_SEC_SCIF           (D_BOOT_MODE_INFO_SECURE | D_BOOT_MODE_INFO_NRM_SCIF)
+
+#define D_BOOT_TRANS_RESULT_INIT            (0xFFFFu)           /* Initialized value for result to transmit image   */
+
+#define D_BOOT_SIGNATURE                    (0xAA55u)           /* Signature on program size block */
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+extern int32_t rom_main(void);
+
+#endif /* BOOTCOM_H */
diff --git a/plat/renesas/rz/common/drivers/sd/boot_esd.h b/plat/renesas/rz/common/drivers/sd/boot_esd.h
new file mode 100644
index 000000000..0dfcb8c52
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/boot_esd.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : boot_esd.h
+ * Version      : 1.0
+ * Description  : eSD boot module dependent header file.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef BOOT_ESD_H
+#define BOOT_ESD_H
+
+#define        NULL                               (0)                      /* NULL */
+
+#define        DEF_FLAG_ON                        (1)                      /* Flag "ON" definition */
+#define        DEF_FLAG_OFF                       (0)                      /* Flag "OFF" definition */
+
+/* Borrowed from eMMC*/
+#define D_STAT_CHECK_RESULT_PASS  (0x00000001)
+#define D_STAT_EXTENDED_BOOT_MODE (0x00000002)
+#define D_STAT_CHECK_RESULT_FAIL  (0x00001000)
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+/* Buffer area */
+/* Work area dedicated to eSD driver library (Size specified by library) */
+extern uint64_t     gl_uwWorkBuffer[ ESD_SIZE_OF_INIT / sizeof(uint64_t)];
+
+/* Struct pointer */
+extern stESD_BOOT_OUTPUT *       gl_pstEsdBootOutput;                       /* Output structure pointer */
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+
+#endif  /* BOOT_ESD_H */
diff --git a/plat/renesas/rz/common/drivers/sd/boot_esd_if.h b/plat/renesas/rz/common/drivers/sd/boot_esd_if.h
new file mode 100644
index 000000000..d7d7367f3
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/boot_esd_if.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : boot_esd_if.h
+ * Version      : 1.0
+ * Description  : eSD Boot Interface Definition.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef BOOT_ESD_IF_H
+#define BOOT_ESD_IF_H
+
+/* Access to the SD host controller FIFO */
+#define        USE_DMAC        (0)                             /* DMA access */
+#define        USE_CPU         (1)                             /* CPU access */
+#define        SDC_ACC_TYPE    (USE_CPU)
+
+/* Return value constant definition */
+#define        ESD_BOOT_OK     (0)                          /* normal return */
+#define        ESD_BOOT_NG     (-1)                         /* error return  */
+
+#define        ESD_PARAM_ERROR (-2)
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+/* Output Structure */
+typedef struct stesd_boot_output
+{
+    int32_t             ipartition_number;        /* output  used partition number                           */
+    int32_t             ierror_code;              /* output  error code                                      */
+
+    int32_t             iloadersize_blkno;        /* output  block number of read loader size; sector 1 to 7 */
+    int32_t             iloadersize_blknum;       /* output  sector count of read loader size                */
+    int32_t             iloaderprog_blkno;        /* output  block number of read loader program             */
+    int32_t             iloaderprog_blknum;       /* output  sector count of read loader program             */
+} stESD_BOOT_OUTPUT;
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+
+#endif    /* BOOT_ESD_IF_H */
+/*---------------------------------------------------------------------------*/
+/*      End Of File                                                          */
+/*---------------------------------------------------------------------------*/
diff --git a/plat/renesas/rz/common/drivers/sd/boot_esddev.c b/plat/renesas/rz/common/drivers/sd/boot_esddev.c
new file mode 100644
index 000000000..c5f49b054
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/boot_esddev.c
@@ -0,0 +1,437 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : boot_esddev.c
+ * Version      : 1.0
+ * Description  : Target CPU Interface for eSD driver.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"            /* eSD driver library header */
+#include "boot_esd_if.h"      /* eSD boot interface header */
+#include "boot_esd.h"         /* eSD boot header */
+#include <drivers/delay_timer.h>
+#
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifdef _UT_
+#define SD_DEV_CODE_SEC
+#define SD_DEV_CODE_SEC_RAM
+#define SD_DEV_RODATA_SEC
+#define SD_DEV_RWDATA_SEC
+#define SD_DEV_ZIDATA_SEC
+#else
+
+/*
+#define SD_DEV_CODE_SEC     __attribute__((section("CODE_esd_normal")))
+#define SD_DEV_CODE_SEC_RAM __attribute__((section("P_RAM")))
+#define SD_DEV_RODATA_SEC   __attribute__((section("CONST_esd_normal")))
+#define SD_DEV_RWDATA_SEC   __attribute__((section("DATA_esd_normal")))
+#define SD_DEV_ZIDATA_SEC   __attribute__((section("BSS_esd_normal")))
+*/
+
+#define SD_DEV_CODE_SEC
+#define SD_DEV_CODE_SEC_RAM
+#define SD_DEV_RODATA_SEC
+#define SD_DEV_RWDATA_SEC
+#define SD_DEV_ZIDATA_SEC
+
+#endif
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_init
+ * Description  : initialze eSD H/W
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : none.
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_init ( void )
+{
+    int32_t iret = SD_ERR;
+
+    iret = SD_OK;   /* It's all normal, so it's done correctly. */
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_init
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_power_on
+ * Description  : turn eSD H/W on
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : none.
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_power_on ( void )
+{
+    int32_t iret = SD_ERR;
+
+    do
+    {
+        /* It's all normal, so it's done correctly. */
+        iret = SD_OK;
+    } while(0);
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_power_on
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_power_off
+ * Description  : turn eSD H/W off
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : none.
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_power_off ( void )
+{
+    int32_t iret = SD_ERR;
+
+    do
+    {
+        iret = SD_OK;    /* It's all normal, so it's done correctly. */
+    } while(0);
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_power_off
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_write_data
+ * Description  : write data to eSD
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : uint8_t *buff          : pointer to write buffer
+ *                uintptr_t reg_addr     : data register address of host controller I/P
+ *                uint32_t num           : write byte count
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_write_data ( uint8_t *buff , uintptr_t reg_addr , uint32_t num )
+{
+    int32_t iret = SD_ERR;
+
+    do
+    {
+        iret = SD_OK;   /* It's all normal, so it's done correctly. */
+    } while(0);
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_write_data
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_get_clockdiv
+ * Description  : get eSD clock
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : int32_t clock : clock frequency;
+ *                                 SD_CLK_400kHz ... SD_CLK_50MHz
+ * Return Value : SD_DIV_2    :complete setting to devide by 2
+ *                SD_DIV_4    :complete setting to devide by 4
+ *                SD_DIV_8    :complete setting to devide by 8
+ *                SD_DIV_16   :complete setting to devide by 16
+ *                SD_DIV_32   :complete setting to devide by 32
+ *                SD_DIV_64   :complete setting to devide by 64
+ *                SD_DIV_128  :complete setting to devide by 128
+ *                SD_DIV_256  :complete setting to devide by 256
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC uint32_t esddev_get_clockdiv ( int32_t clock )
+{
+    uint32_t uiret_clkdiv;
+
+    do
+    {
+        switch(clock)
+        {
+
+            case SD_CLK_50MHz:
+            case SD_CLK_25MHz:
+            case SD_CLK_20MHz:
+                uiret_clkdiv = SD_DIV_8;    /* 16.66MHz */
+                break;
+            case SD_CLK_10MHz:
+                uiret_clkdiv = SD_DIV_16;   /* 8.33MHz */
+                break;
+            case SD_CLK_5MHz:
+                uiret_clkdiv = SD_DIV_32;   /* 4.165MHz */
+                break;
+            case SD_CLK_1MHz:
+                uiret_clkdiv = SD_DIV_256;  /* 520KHz */
+                break;
+            case SD_CLK_400kHz:
+                uiret_clkdiv = SD_DIV_512;  /* 260KHz */
+                break;
+            default:
+                uiret_clkdiv = SD_DIV_512;
+                break;
+
+        }
+    } while(0);
+
+    return(uiret_clkdiv);
+}
+/**********************************************************************************************************************
+ * End of function esddev_get_clockdiv
+ *********************************************************************************************************************/
+
+
+/**********************************************************************************************************************
+ * Function Name: esddev_set_port
+ * Description  : select eSD port
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : int32_t mode : selected mode
+ *                               0x0000u : SD_PORT_SERIAL
+ *                               0x0001u : SD_PORT_PARALLEL
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ * Note         : Not implement
+ *              : Check whether selected port or mode at CALLER
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_set_port(int32_t mode)
+{
+    int32_t iret = SD_ERR;
+
+    do
+    {
+        iret = SD_OK;    /* It's all normal, so it's done correctly. */
+    } while(0);
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_set_port
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_int_wait
+ * Description  : wait eSD interrupt
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : int32_t time : time-out value[msec]
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_int_wait ( int32_t msec )
+{
+    int32_t iret = SD_ERR;
+    int32_t isubret = SD_ERR;
+    int32_t cnt = 0;
+    do 
+    {
+        while( cnt < msec )
+        {
+            isubret = esd_check_int();
+            if( SD_OK == isubret )
+            {
+                /* Loop break with SD host controller interrupt detection */
+                break;
+            }
+            udelay(1000); //busy wait with 1msec.
+            cnt++;
+        }
+        if( SD_OK != isubret)
+        {
+            /* Error break without SD host controller interrupt detection */
+            break;
+        }
+        /* It's all normal, so it's done correctly. */
+        iret = SD_OK;
+    } while(0);
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_int_wait
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_loc_cpu
+ * Description  : lock of eSD interrupt
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : none.
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_loc_cpu ( void )
+{
+    int32_t iret = SD_ERR;
+
+    do
+    {
+        /* Lock of SD host controller interrupt */
+        /* It's all normal, so it's done correctly. */
+        iret = SD_OK;
+    } while(0);
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_loc_cpu
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_unl_cpu
+ * Description  : unlock of eSD interrupt
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : none.
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_unl_cpu ( void )
+{
+    int32_t iret = SD_ERR;
+
+    do
+    {
+        /* It's all normal, so it's done correctly. */
+        iret = SD_OK;
+    } while(0);
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_unl_cpu
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_init_dma
+ * Description  : initialize eSD DMA
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : uintptr_t buff_addr : start address of buffer
+ *                uintptr_t reg_addr  : start address of register
+ *                uint32_t   cnt      : count of transfer
+ *                int32_t   dir       : direction of transfer
+ *                                        0 : register to buffer
+ *                                        1 : buffer to register
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_init_dma(uintptr_t buffadr, uintptr_t regadr, uint32_t cnt, int32_t dir)
+{
+    return(SD_ERR);
+}
+/**********************************************************************************************************************
+ * End of function esddev_init_dma
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_wait_dma_end
+ * Description  : wait for completion of eSD DMA transfer
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : int32_t cnt : byte count of DMA transfer
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_wait_dma_end ( uint32_t cnt )
+{
+    return(SD_ERR);
+}
+/**********************************************************************************************************************
+ * End of function esddev_wait_dma_end
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_disable_dma
+ * Description  : disable eSD DMA
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : none.
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_disable_dma ( void )
+{
+    return(SD_ERR);
+}
+/**********************************************************************************************************************
+ * End of function esddev_disable_dma
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esddev_read_data
+ * Description  : read data from eSD
+ *                for more information, refer to eSD card driver manual..
+ * Arguments    : uint8_t *buff      : pointer to read buffer
+ *                uintptr_t reg_addr : data register address of host controller I/P
+ *                int32_t num        : read byte count
+ * Return Value : SD_OK    : 0
+ *              : SD_ERR   : -1.
+ *********************************************************************************************************************/
+SD_DEV_CODE_SEC int32_t esddev_read_data ( uint8_t *buff, uintptr_t reg_addr, uint32_t num )
+{
+
+    int32_t iret = SD_ERR;
+    uint32_t i;
+    uint32_t *p_reg = (uint32_t *)(reg_addr);
+    uint32_t *p_ptr = (uint32_t *)buff;
+    uint32_t tmp;
+
+    do 
+    {
+        num+=3;                                             /* Size rounding adjustment for accessing */
+        num /=4;
+    
+        if((uintptr_t)buff & 0x3)
+        {                           /* Operation with 4bytes access */
+            for(i=num; i > 0 ; i--)
+            {
+                tmp = *p_reg;                                 /* Read 4bytes data from FIFO */
+
+                *buff++ = (uint8_t)(tmp);
+                *buff++ = (uint8_t)(tmp >> 8);
+                *buff++ = (uint8_t)(tmp >> 16);
+                *buff++ = (uint8_t)(tmp >> 24);
+            }
+        }
+        else
+        {
+            for(i=num; i > 0 ; i--)
+            {                           /* Operation with 4byte access */
+                *p_ptr++ = *p_reg;          /* Read and store data in buffer, every 2 bytes */
+            }
+        }
+        iret = SD_OK;                   /* It's all normal, so it's done correctly. */
+    } while(0);
+
+    return(iret);
+}
+/**********************************************************************************************************************
+ * End of function esddev_read_data
+ *********************************************************************************************************************/
+
+/*---------------------------------------------------------------------------*/
+/*      End Of File                                                          */
+/*---------------------------------------------------------------------------*/
+
diff --git a/plat/renesas/rz/common/drivers/sd/cpg_iodefine.h b/plat/renesas/rz/common/drivers/sd/cpg_iodefine.h
new file mode 100644
index 000000000..c7ead98f9
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/cpg_iodefine.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : cpg_iodefine.h
+ * Version      : 1.0
+ * Description  : iodefine header file.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef CPG_IODEFINE_H
+#define CPG_IODEFINE_H
+
+#define CPG_BASE_ADDR   (0x11010000uL)                          /* Base address of CPG */
+#define CPG_PLL1_STBY       (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x000uL))/* PLL standby control register for CA55 */
+#define CPG_PLL1_CLK1       (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x004uL))   /* PLL output set register1 for CA55 */
+#define CPG_PLL1_CLK2       (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x008uL))   /* PLL output set register2 for CA55 */
+#define CPG_PLL1_SETTING    (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x040uL))   /* PLL set register for CA55  */
+#define CPG_PL1_DDIV        (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x200uL))   /* Divider register for CA55's clock */
+
+#define CPG_PL3A_DDIV       (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x208uL))   /* Division rate setting register
+                                                                                   for PLL3*/
+
+#define CPG_PL2SDHI_DSEL    (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x218uL))   /* Source clock set register for SDHI*/
+
+#define CPG_CLKSTATUS       (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x280uL))   /* Clock status monitor register */
+
+#define CPG_PL3_SSEL        (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x408uL))   /* Source clock selecting register
+                                                                                   for PLL3*/
+
+#define CPG_CLKON_OSTM      (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x534uL))   /* Clock on/off register for OSTM0 */
+#define CPG_CLKON_SPI_MULTI (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x550uL))   /* Clock on/off register for SPI */
+#define CPG_CLKON_SDHI      (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x554uL))   /* Clock on/off register for SDHI0 */
+#define CPG_CLKON_SCIF      (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x584uL))   /* Clock on/off register for SCIF  */
+#define CPG_CLKON_GPIO      (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x598uL))   /* Clock on/off register for GPIO  */
+
+#define CPG_CLKMON_OSTM     (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x6B4uL))   /* Clock monitor register for OSTM 0*/
+#define CPG_CLKMON_SPI_MULTI    (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x6D0uL))   /* Clock monitor reg. for SPI */
+#define CPG_CLKMON_SDHI     (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x6D4uL))   /* Clock monitor register for SDHI0 */
+#define CPG_CLKMON_SCIF     (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x704uL))   /* Clock monitor register for SCIF  */
+#define CPG_CLKMON_GPIO     (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x718uL))   /* Clock monitor register for GPIO  */
+
+#define CPG_RST_OSTM        (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x834uL))   /* Reset on/off register for OSTM */
+
+#define CPG_RST_SPI         (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x850uL))   /* Reset on/off register for SPI */
+#define CPG_RST_SDHI        (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x854uL))   /* Reset on/off register for SDHI */
+#define CPG_RST_SCIF        (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x884uL))   /* Reset on/off register for SCIF */
+#define CPG_RST_GPIO        (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x898uL))   /* Reset on/off register for GPIO */
+
+#define CPG_RSTMON_OSTM     (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x9B4uL))   /* Reset monitor register for OSTM */
+
+#define CPG_RSTMON_SPI      (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x9D0uL))   /* Reset monitor register for SPI */
+#define CPG_RSTMON_SDHI     (*(volatile uint32_t *)(CPG_BASE_ADDR + 0x9D4uL))   /* Reset monitor register for SDHI */
+#define CPG_RSTMON_SCIF     (*(volatile uint32_t *)(CPG_BASE_ADDR + 0xA04uL))   /* Reset monitor register for SCIF */
+#define CPG_RSTMON_GPIO     (*(volatile uint32_t *)(CPG_BASE_ADDR + 0xA18uL))   /* Reset monitor register for GPIO */
+
+/*** CPG_PL1_DDIV ***/
+#define CPG_PL1_WEN_MSK     (0x00010000uL)                      /* Mask bit pattern of write-enable */
+#define CPG_PL1_WEN         (0x00010000uL)                      /* Write-enable  to this register */
+#define CPG_PL1_WDIS        (0x00000000uL)                      /* Write-disable to this register */
+
+#define CPG_PL1_DIV_MSK     (0x00000003uL)                      /* Mask bit pattern of division rate */
+#define CPG_PL1_DIV1        (0x00000000uL)                      /* rate, 1/1 */
+#define CPG_PL1_DIV2        (0x00000001uL)                      /* rate, 1/2 */
+#define CPG_PL1_DIV4        (0x00000002uL)                      /* rate, 1/4 */
+#define CPG_PL1_DIV8        (0x00000003uL)                      /* rate, 1/8 */
+
+/*** Bit define of CPG_PL3A_DDIV register ***/
+#define CPG_PL3A_DDIV_DIVPL3C_WEN           (0x01000000uL)      /* Write-enable DIVPL3C_WEN bit */
+#define CPG_PL3A_DDIV_DIVPL3C_MASK          (0x00000700uL)      /* DIV_PLL3_C: mask */
+#define CPG_PL3A_DDIV_DIVPL3C_SET_NODIV     (0x00000000uL)      /* DIV_PLL3_C: no divided */
+#define CPG_PL3A_DDIV_DIVPL3C_SET_HLF       (0x00000100uL)      /* DIV_PLL3_C: half */
+#define CPG_PL3A_DDIV_DIVPL3C_SET_DIV4      (0x00000200uL)      /* DIV_PLL3_C: divide by  4 */
+#define CPG_PL3A_DDIV_DIVPL3C_SET_DIV8      (0x00000300uL)      /* DIV_PLL3_C: divide by  8 */
+#define CPG_PL3A_DDIV_DIVPL3C_SET_DIV16     (0x00000400uL)      /* DIV_PLL3_C: divide by 16 */
+
+/*** Bit define of CPG_PL3_SSEL register ***/
+#define CPG_PL3_SSEL_WEN                    (0x01110000uL)      /* Write-enable Bit[8], Bit[4] and Bit[0] */
+#define CPG_PL3_SSEL_FOUT3_2                (0x00000011uL)      /* FOUT3/2 system */
+
+/*** Bit define of CPG_PL2SDHI_DSEL register ***/
+#define CPG_PL2SDHI_DSEL_SDHI0_WEN          (0x00010000uL)      /* Write-enable  SEL_SDHI0_SET bit */
+#define CPG_PL2SDHI_DSEL_SDHI0_WDIS         (0x00000000uL)      /* Write-disable SEL_SDHI0_SET bit */
+
+#define CPG_PL2SDHI_DSEL_SDHI0_SET_MSK      (0x00000003uL)      /* Mask bit pattern of SEL_SDHI0_SET_MSK bit */
+#define CPG_PL2SDHI_DSEL_SDHI0_CLK800       (0x00000000uL)      /* 800MHz */
+#define CPG_PL2SDHI_DSEL_SDHI0_CLK533       (0x00000001uL)      /* 533MHz */
+#define CPG_PL2SDHI_DSEL_SDHI0_PLL2_DIV8    (0x00000002uL)      /* 1/8  * PLL2 */
+#define CPG_PL2SDHI_DSEL_SDHI0_PLL2_DIV12   (0x00000003uL)      /* 1/12 * PLL2 */
+
+#define CPG_CLKSTATUS_SDHI0_MSK (0x10000000uL)                  /* Mask bit pattern of clock status for SDHI0 */
+#define CPG_CLKSTATUS_SDHI0_BSY (0x10000000uL)                  /* Busy to change clock for SDHI0 */
+
+/*** CPG_CLKON ***/
+#define CPG_CLKON_WEN_CH0       (0x00010000uL)                  /* Write-enable  to this register */
+#define CPG_CLKON_WDIS_CH0      (0x00000000uL)                  /* Write-disable to this register */
+
+
+/*** Bit define of CPG_CLKON_SPIMULTI/CPG_CLKMON_SPIMULTI register ***/
+#define CPG_CLKON_OSTM0_ON      (0x00000001uL)                  /* OSTM0_PCLK on */
+#define CPG_CLKON_OSTM0_OFF     (0x00000000uL)
+
+#define CPG_RST_OSTM0_OFF       (0x00000001uL)                  /* Reset off for OSTM0 */
+#define CPG_RST_OSTM0_ON        (0x00000000uL)                  /* Reset on  for OSTM0 */
+#define CPG_RST_OSTM0_WEN       (0x00010000uL)                  /* Write-enable UNIT0_RST bit for OSTM0 */
+#define CPG_RSTMON_OSTM0_MSK    (0x00000001uL)
+#define CPG_RSTMON_OSTM0_ON     (0x00000001uL)                  /* Monitor reset on for OSTM0 */
+#define CPG_RSTMON_OSTM0_OFF    (0x00000000uL)                  /* Monitor reset off for OSTM0 */
+
+/*** Bit define of CPG_CLKON_SPIMULTI/CPG_CLKMON_SPIMULTI register ***/
+#define CPG_CLKON_SPIMULTI_ON   (0x00000003uL)                  /* SPI_CLK0 and SPI_CLK1 on */
+#define CPG_CLKON_SPIMULTI_OFF  (0x00000000uL)
+#define CPG_CLKON_SPIMULTI_WEN  (0x00030000uL)
+#define CPG_CLKON_SPIMULTI_WDIS (0x00000000uL)
+#define CPG_CLKMON_SPIMULTI_MSK (0x00000003uL)
+#define CPG_CLKMON_SPIMULTI_ON  (0x00000003uL)
+#define CPG_CLKMON_SPIMULTI_OFF (0x00000000uL)
+
+#define CPG_RST_SPI0_OFF        (0x00000001uL)                  /* Reset off for SPI0 */
+#define CPG_RST_SPI0_ON         (0x00000000uL)                  /* Reset on  for SPI0 */
+#define CPG_RST_SPI0_WEN        (0x00010000uL)                  /* Write-enable UNIT0_RST bit for SPI0 */
+#define CPG_RSTMON_SPI0_MSK     (0x00000001uL)
+#define CPG_RSTMON_SPI0_ON      (0x00000001uL)                  /* Monitor reset on for SPI0 */
+#define CPG_RSTMON_SPI0_OFF     (0x00000000uL)                  /* Monitor reset off for SPI0 */
+
+/*** Bit define of CPG_CLKON_SDHI/CPG_CLKMON_SDHI register ***/
+#define CPG_CLKON_SDHI0_ON      (0x0000000FuL)                  /* SDHI0_IMCLK/SDHI0_IMCLK2/SDHI0_CLK_HS/SDHI0_ACLK on*/
+#define CPG_CLKON_SDHI0_OFF     (0x00000000uL)
+#define CPG_CLKON_WEN_SDHI0     (0x000F0000uL)                  /* Write-enable  to this register */
+#define CPG_CLKON_WDIS_SDHI0    (0x00000000uL)                  /* Write-disable to this register */
+#define CPG_CLKMON_SDHI0_ON     (0x0000000FuL)                  /* Monitor clock on for SDHI0 */
+#define CPG_CLKMON_SDHI0_OFF    (0x00000000uL)                  /* Monitor clock off for SDHI0 */
+
+#define CPG_RST_SDHI0_ON        (0x00000000uL)                  /* Reset on for SDHI0 */
+#define CPG_RST_SDHI0_OFF       (0x00000001uL)                  /* Reset off for SDHI0 */
+#define CPG_RST_SDHI0_WEN       (0x00010000uL)                  /* Write-enable  UNIT0_RSTB bit for SDHI0 */
+#define CPG_RST_SDHI0_WDIS      (0x00000000uL)                  /* Write-disable UNIT0_RSTB bit for SDHI0 */
+#define CPG_RSTMON_SDHI0_ON     (0x00000001uL)                  /* Monitor reset on for SDHI0 */
+
+/*** Bit define of CPG_CLKON_SCIF/CPG_CLKMON_SCIF register ***/
+#define CPG_CLKON_SCIF0_ON      (0x00000001uL)                  /* CLK0_ON */
+#define CPG_CLKON_SCIF0_OFF     (0x00000000uL)
+
+#define CPG_RST_SCIF0_OFF       (0x00000001uL)                  /* Reset off for SCIF0 */
+#define CPG_RST_SCIF0_WEN       (0x00010000uL)                  /* Write-enable  UNIT0_RSTB bit for SCIF0 */
+#define CPG_RST_SCIF0_WDIS      (0x00000000uL)                  /* Write-disable UNIT0_RSTB bit for SCIF0 */
+#define CPG_RSTMON_SCIF0_MSK    (0x00000001uL)
+#define CPG_RSTMON_SCIF0_ON     (0x00000001uL)                  /* Monitor reset on for SCIF0 */
+#define CPG_RSTMON_SCIF0_OFF    (0x00000000uL)                  /* Monitor reset off for SCIF0 */
+
+/*** Bit define of CPG_CLKON_GPIO/CPG_CLKMON_GPIO register ***/
+#define CPG_CLKON_GPIO_ON       (0x00000001uL)                  /* CLK0_ON */
+#define CPG_CLKON_GPIO_OFF      (0x00000000uL)
+
+#define CPG_RST_GPIO_OFF        (0x00000007uL)                  /* Reset off for GPIO */
+#define CPG_RST_GPIO_WEN        (0x00070000uL)                  /* Write-enable  UNIT0_RSTB bit for GPIO */
+#define CPG_RST_GPIO_WDIS       (0x00000000uL)                  /* Write-disable UNIT0_RSTB bit for GPIO */
+#define CPG_RSTMON_GPIO_OFF     (0x00000000uL)                  /* Monitor reset off for GPIO */
+#define CPG_RSTMON_GPIO_MSK     (0x00000007uL)                  /* Bit mask monitor reset off for GPIO */
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+
+#endif /* CPG_IODEFINE_H */
diff --git a/plat/renesas/rz/common/drivers/sd/esdif.h b/plat/renesas/rz/common/drivers/sd/esdif.h
new file mode 100644
index 000000000..a09b2994d
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/esdif.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : esdif.h
+ * Version      : 1.0
+ * Description  : SD Driver interface header file.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef SDDRV_H
+#define SDDRV_H
+
+/* ==== Define  ==== */
+/* ---- SD Driver work buffer ---- */
+#define SD_SIZE_OF_INIT         (640)
+
+/* ---- Error code ---- */
+#define SD_OK                   (0)             /* OK */
+#define SD_ERR                  (-1)            /* General error */
+#define SD_ERR_WP               (-2)            /* Write protect error */
+
+#define SD_ERR_RES_TOE          (-4)            /* Response time out error */
+#define SD_ERR_CARD_TOE         (-5)            /* Card time out error */
+#define SD_ERR_END_BIT          (-6)            /* End bit error */
+#define SD_ERR_CRC              (-7)            /* CRC error */
+
+#define SD_ERR_HOST_TOE         (-9)            /* Host time out error */
+#define SD_ERR_CARD_ERASE       (-10)           /* Card erase error */
+#define SD_ERR_CARD_LOCK        (-11)           /* Card lock error */
+#define SD_ERR_CARD_UNLOCK      (-12)           /* Card unlock error */
+#define SD_ERR_HOST_CRC         (-13)           /* Host CRC error */
+#define SD_ERR_CARD_ECC         (-14)           /* Card internal ECC error */
+#define SD_ERR_CARD_CC          (-15)           /* Card internal error */
+#define SD_ERR_CARD_ERROR       (-16)           /* Unknown card error */
+#define SD_ERR_CARD_TYPE        (-17)           /* Non support card type */
+#define SD_ERR_NO_CARD          (-18)           /* No card */
+#define SD_ERR_ILL_READ         (-19)           /* Illegal buffer read */
+#define SD_ERR_ILL_WRITE        (-20)           /* Illegal buffer write */
+#define SD_ERR_AKE_SEQ          (-21)           /* The sequence of authentication process */
+#define SD_ERR_OVERWRITE        (-22)           /* CID/CSD overwrite error */
+#define SD_ERR_CPU_IF           (-30)           /* Target CPU interface function error  */
+#define SD_ERR_STOP             (-31)           /* User stop */
+
+#define SD_ERR_FILE_FORMAT      (-52)           /* CSD register file format error  */
+
+#define SD_ERR_ILL_FUNC         (-60)           /* Invalid function request error */
+
+#define SD_ERR_IFCOND_VER       (-70)           /* Interface condition version error */
+
+#define SD_ERR_IFCOND_ECHO      (-72)           /* Interface condition echo back pattern error */
+#define SD_ERR_INTERNAL         (-99)           /* Driver software internal error */
+#define SD_ERR_OUT_OF_RANGE     (-80)           /* The argument was out of range */
+#define SD_ERR_ADDRESS_ERROR    (-81)           /* Misassigned address */
+#define SD_ERR_BLOCK_LEN_ERROR  (-82)           /* Transfered block length is not allowed */
+#define SD_ERR_ILLEGAL_COMMAND  (-83)           /* Command not legal  */
+#define SD_ERR_RESERVED_ERROR18 (-84)           /* Reserved bit 18 Error */
+#define SD_ERR_RESERVED_ERROR17 (-85)           /* Reserved bit 17 Error */
+#define SD_ERR_CMD_ERROR        (-86)           /* SD_INFO2 bit  0 CMD error */
+#define SD_ERR_CBSY_ERROR       (-87)           /* SD_INFO2 bit 14 CMD Type Reg Busy error */
+#define SD_ERR_NO_RESP_ERROR    (-88)           /* SD_INFO1 bit  0 No Response error */
+
+/* ---- Driver mode ---- */
+#define SD_MODE_POLL            (0x0000ul)      /* Status check mode is software polling */
+
+#define SD_MODE_SW              (0x0000ul)      /* Data transfer mode is software */
+#define SD_MODE_DMA             (0x0002ul)      /* Data transfer mode is DMA */
+
+/* ---- Support mode ---- */
+
+#define SD_MODE_IO              (0x0010ul)      /* Memory and io cards are supported */
+
+#define SD_MODE_DS              (0x0000ul)      /* Only default speed mode is supported */
+#define SD_MODE_HS              (0x0040ul)      /* High speed mode is also supported */
+
+#define SD_MODE_VER2X           (0x0080ul)      /* Ver2.x host (high capacity and dual voltage) */
+
+/* ---- Media voltage ---- */
+
+#define SD_VOLT_3_3             (0x00100000ul)
+
+/* ---- Media type ---- */
+#define SD_MEDIA_UNKNOWN        (0x0000u)       /* Unknown media */
+#define SD_MEDIA_MMC            (0x0010u)       /* MMC card */
+#define SD_MEDIA_SD             (0x0020u)       /* SD Memory card */
+#define SD_MEDIA_IO             (0x0001u)       /* SD IO card */
+#define SD_MEDIA_MEM            (0x0030u)       /* Memory card */
+#define SD_MEDIA_COMBO          (0x0021u)       /* SD COMBO card */
+
+/* ---- write protect info --- */
+
+#define SD_WP_ROM               (0x0010u)       /* Card is SD-ROM */
+
+/* ---- SD clock div ---- */                    /* IMCLK is host controller clock */
+#define SD_DIV_512              (0x0080u)       /* SDCLOCK = IMCLK/512 */
+#define SD_DIV_256              (0x0040u)       /* SDCLOCK = IMCLK/256 */
+#define SD_DIV_32               (0x0008u)       /* SDCLOCK = IMCLK/32 */
+#define SD_DIV_16               (0x0004u)       /* SDCLOCK = IMCLK/16 */
+#define SD_DIV_8                (0x0002u)       /* SDCLOCK = IMCLK/8 */
+
+/* ---- SD clock define ---- */                 /* Max frequency */
+#define SD_CLK_400kHz           (0x0000u)       /* 400kHz */
+#define SD_CLK_1MHz             (0x0001u)       /* 1MHz */
+#define SD_CLK_5MHz             (0x0002u)       /* 5MHz */
+#define SD_CLK_10MHz            (0x0003u)       /* 10MHz */
+#define SD_CLK_20MHz            (0x0004u)       /* 20MHz */
+#define SD_CLK_25MHz            (0x0005u)       /* 25MHz */
+#define SD_CLK_50MHz            (0x0006u)       /* 50MHz (phys spec ver1.10) */
+
+/* @060526 for SD phy ver2.0 */
+
+/* ---- IO initialize flags define ---- */      /* Add for IO */
+
+#define SD_IO_POWER_INIT        (0x04u)         /* Power on initialized */
+
+/* ---- SD port mode ---- */
+#define SD_PORT_SERIAL          (0x0000u)       /* 1bit mode */
+#define SD_PORT_PARALLEL        (0x0001u)       /* 4bits mode */
+
+/* ---- SD Card detect port ---- */
+#define SD_CD_SOCKET            (0x0000u)       /* CD pin */
+#define SD_CD_DAT3              (0x0001u)       /* DAT3 pin */
+
+/* ---- SD Card detect interrupt ---- */
+#define SD_CD_INT_DISABLE       (0x0000u)       /* Card detect interrupt disable */
+#define SD_CD_INT_ENABLE        (0x0001u)       /* Card detect interrupt enable */
+
+/* ---- Format mode ---- */
+#define SD_FORMAT_QUICK         (0x0000u)       /* Quick format */
+#define SD_FORMAT_FULL          (0x0001u)       /* Full format */
+
+/* ---- SD Driver work buffer ---- */
+#define ESD_SIZE_OF_INIT        (SD_SIZE_OF_INIT+4)
+/* ---- Media type ---- */
+#define SD_MEDIA_EMBEDDED       (0x8000u)       /* Embedded media */
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+/* ==== API prototype ===== */
+/* ---- Access library I/F ---- */
+extern int32_t esd_init(uintptr_t base, void *workarea, int32_t cd_port);
+extern int32_t esd_check_media(void);
+extern int32_t esd_mount(uint32_t mode, uint32_t voltage);
+extern int32_t esd_read_sect(uint8_t *buff, uint32_t psn, int32_t cnt);
+extern int32_t esd_get_type(uint16_t *type, uint8_t *speed, uint8_t *capa);
+extern int32_t esd_check_int(void);
+extern int32_t esd_set_buffer(void *buff, uint32_t size);
+extern int32_t esd_get_partition_id(int32_t *id);
+extern int32_t esd_main(void);
+
+/* ---- Target CPU I/F ---- */
+extern int32_t esddev_init(void);
+extern int32_t esddev_power_on(void);
+extern int32_t esddev_power_off(void);
+extern int32_t esddev_read_data( uint8_t *buff, uintptr_t reg_addr, uint32_t num);
+extern int32_t esddev_write_data(uint8_t *buff, uintptr_t reg_addr, uint32_t num);
+extern uint32_t esddev_get_clockdiv ( int32_t clock );
+extern int32_t esddev_set_port(int32_t mode);
+extern int32_t esddev_int_wait(int32_t msec);
+extern int32_t esddev_init_dma(uintptr_t buffadr, uintptr_t regadr, uint32_t cnt, int32_t dir);
+extern int32_t esddev_wait_dma_end(uint32_t cnt);
+extern int32_t esddev_disable_dma(void);
+extern int32_t esddev_loc_cpu(void);
+extern int32_t esddev_unl_cpu(void);
+
+#endif    /* SDDRV_H */
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/r_typedefs.h b/plat/renesas/rz/common/drivers/sd/r_typedefs.h
new file mode 100644
index 000000000..1830a4ff2
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/r_typedefs.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : r_typedefs.h
+ * Version      : 1.0
+ * Description  : basic type definition.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stddef.h>
+#include <stdbool.h>
+#include <stdint.h>
+#if defined(__ARM_NEON__)
+#include <arm_neon.h>
+#endif /* __ARM_NEON__ */
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef R_TYPEDEFS_H
+#define R_TYPEDEFS_H
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+#if !defined(__ARM_NEON__)
+typedef float               float32_t;
+typedef double              float64_t;
+#endif /* __ARM_NEON__ */
+
+typedef char                char_t;
+typedef int                 bool_t;
+typedef int                 int_t;
+typedef long double         float128_t;
+typedef signed long         long_t;
+typedef unsigned long       ulong_t;
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+
+#endif /* R_TYPEDEFS_H */
diff --git a/plat/renesas/rz/common/drivers/sd/sd.h b/plat/renesas/rz/common/drivers/sd/sd.h
new file mode 100644
index 000000000..e3f52005f
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd.h
@@ -0,0 +1,642 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd.h
+ * Version      : 1.0
+ * Description  : SD Driver header file.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include "sys_sel.h"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef SD_H
+#define SD_H
+
+/* ==== Option ==== */
+#ifndef SD_IO_FORCE_BYTE    /* When SDIO is published, describe the following macro in sdif.h */
+#define SD_IO_FORCE_BYTE    ( 0x0010u )  /* Byte access only  */
+#endif
+
+#define _SDHI0_BASE_    ( 0x11C00000U )
+
+
+/* ==== SDHI register address ==== */
+#define SD_CMD              ( 0x0000 )  /* SD Command */
+#define SD_PORTSEL          ( 0x0008 )  /* SD Port Selection */
+#define SD_ARG0             ( 0x0010 )  /* SD Command Argument (low  16bits) */
+#define SD_ARG1             ( 0x0018 )  /* SD Command Argument (high 16bits) */
+#define SD_STOP             ( 0x0020 )  /* Data Stop */
+#define SD_SECCNT           ( 0x0028 )  /* Block Count */
+#define SD_RESP0            ( 0x0030 )  /* Response R23-8 */
+#define SD_RESP1            ( 0x0038 )  /* Response R39-24 */
+#define SD_RESP2            ( 0x0040 )  /* Response R55-40 */
+#define SD_RESP3            ( 0x0048 )  /* Response R71-56 */
+#define SD_RESP4            ( 0x0050 )  /* Response R87-72 */
+#define SD_RESP5            ( 0x0058 )  /* Response R103-88 */
+#define SD_RESP6            ( 0x0060 )  /* Response R119-104 */
+#define SD_RESP7            ( 0x0068 )  /* Response R127-120 */
+#define SD_INFO1            ( 0x0070 )  /* SD Interrupt Flag(1) */
+#define SD_INFO2            ( 0x0078 )  /* SD Interrupt Flag(2) */
+#define SD_INFO1_MASK       ( 0x0080 )  /* SD Interrupt Flag(1) Mask */
+#define SD_INFO2_MASK       ( 0x0088 )  /* SD Interrupt Flag(2) Mask */
+#define SD_CLK_CTRL         ( 0x0090 )  /* SD Clock Control */
+#define SD_SIZE             ( 0x0098 )  /* Block Size */
+#define SD_OPTION           ( 0x00A0 )  /* Access Option */
+#define SD_ERR_STS1         ( 0x00B0 )  /* CMD,CRC,END Error Status */
+#define SD_ERR_STS2         ( 0x00B8 )  /* Timeout Error Status  */
+#define SD_BUF0             ( 0x00C0 )  /* SD Buffer */
+#define SDIO_MODE           ( 0x00D0 )  /* SDIO Mode */
+#define SDIO_INFO1          ( 0x00D8 )  /* SDIO Interrupt Flag */
+#define SDIO_INFO1_MASK     ( 0x00E0 )  /* SDIO Interrupt Flag Mask */
+#define SOFT_RST            ( 0x0380 )  /* Soft Reset */
+#define VERSION             ( 0x0388 )  /* Version */
+#define HOST_MODE           ( 0x0390 )  /* SWAP Control */
+/* Unused */
+/*#define POWER_CTRL      ((0xf2u<<SD_REG_SHIFT)+SD_BYTE_OFFSET)*/  /* Power Control */
+#define EXT_SDIO            ( 0x03D0 )  /* Extended SDIO Interrupt Flag */
+#define EXT_WP              ( 0x03D8 )  /* Extended Write Protect */
+#define EXT_CD              ( 0x03E0 )  /* Extended Card Detect */
+#define EXT_CD_DAT3         ( 0x03E8 )  /* Extended Card Detect(DAT3) */
+#define EXT_CD_MASK         ( 0x03F0 )  /* Extended Card Detect Mask */
+#define EXT_CD_DAT3_MASK    ( 0x03F8 )  /* Extended Card Detect(DAT3) Mask */
+#define CC_EXT_MODE         ( 0x0360 )  /* DMA Mode Enable */
+
+/* ==== Command type ==== */
+/* ---- SD commands ---- */
+#define CMD0                (0u)        /* GO_IDLE_STATE */
+#define CMD1                (1u)        /* SD_SEND_OP_COND for MMC */
+#define CMD2                (2u)        /* ALL_SEND_CID */
+#define CMD3                (3u)        /* SEND_RELATIVE_ADDR */
+#define CMD4                (4u)        /* SET_DSR */
+#define CMD7                (7u)        /* SELECT/DESELECT_CARD */
+#define CMD9                (9u)        /* SEND_CSD */
+#define CMD10               (10u)       /* SEND_CID */
+#define CMD12               (12u)       /* STOP_TRANSMISSION */
+#define CMD13               (13u)       /* SEND_STATUS */
+#define CMD15               (15u)       /* GO_INACTIVE_STATE */
+#define CMD16               (16u)       /* SET_BLOCK_LEN */
+#define CMD17               (17u)       /* READ_SINGLE_BLOCK */
+#define CMD18               (18u)       /* READ_MULTIPLE_BLOCK */
+#define CMD24               (24u)       /* WRITE_SINGLE_BLOCK */
+#define CMD25               (25u)       /* WRITE_MULTIPLE_BLOCK */
+#define CMD27               (27u)       /* PROGRAM_CSD */
+#define CMD28               (28u)       /* SET_WRITE_PROT */
+#define CMD29               (29u)       /* CLR_WRITE_PROT */
+#define CMD30               (30u)       /* SEND_WRITE_PROT */
+#define CMD32               (32u)       /* ERASE_WR_BLK_START */
+#define CMD33               (33u)       /* ERASE_WR_BLK_END */
+#define CMD35               (35u)       /* ERASE_GROUP_START */
+#define CMD36               (36u)       /* ERASE_GROUP_END */
+#define CMD38               (38u)       /* ERASE */
+#define CMD42               (42u)       /* LOCK_UNLOCK */
+#define CMD55               (55u)       /* APP_CMD */
+
+/* ---- IO commnds ---- */    /* add for IO */
+#define CMD5                (0x4705u)   /* IO_SEND_OP_COND */
+#define CMD52_W             (0x4434u)   /* IO_WRITE_DIRECT */
+#define CMD52_R             (0x5434u)   /* IO_READ_DIRECT */
+#define CMD53_W_BLOCK       (0x6c35u)   /* IO_WRITE_EXTENDED_BLOCK */
+#define CMD53_W_BYTE        (0x4c35u)   /* IO_WRITE_EXTENDED_BYTE */
+#define CMD53_R_BLOCK       (0x7c35u)   /* IO_READ_EXTENDED_BLOCK */
+#define CMD53_R_BYTE        (0x5c35u)   /* IO_READ_EXTENDED_BYTE */
+
+/* ---- Switch function command (phys spec ver1.10) ---- */
+#define CMD6                (0x1C06u)   /* SWITCH_FUNC */
+
+/* ---- Dual voltage inquiry command (phys spec ver2.0) ---- */
+#define CMD8                (0x0408u)   /* SEND_IF_COND */
+
+/* ---- Application specific commands ---- */
+#define ACMD6               (0x40u|6u)  /* SET_BUS_WIDTH */
+#define ACMD13              (0x40u|13u) /* SD_STATUS */
+#define ACMD22              (0x40u|22u) /* SEND_NUM_WR_BLOCKS */
+#define ACMD23              (0x40u|23u) /* SET_WR_BLK_ERASE_COUNT */
+#define ACMD41              (0x40u|41u) /* SD_SEND_OP_COND */
+#define ACMD42              (0x40u|42u) /* SET_CLR_CARD_DETECT */
+#define ACMD51              (0x40u|51u) /* SEND_SCR */
+
+/* ---- Security commands (security spec ver1.01) ---- */
+#define ACMD18              (0x40u|18u) /* SECURE_READ_MULTIPLE_BLOCK */
+#define ACMD25              (0x40u|25u) /* SECURE_WRITE_MULTIPLE_BLOCK */
+#define ACMD26              (0x40u|26u) /* SECURE_WRITE_MKB */
+#define ACMD38              (0x40u|38u) /* SECURE_ERASE */
+#define ACMD43              (0x40u|43u) /* GET_MKB */
+#define ACMD44              (0x40u|44u) /* GET_MID */
+#define ACMD45              (0x40u|45u) /* SET_CER_RN1 */
+#define ACMD46              (0x40u|46u) /* GET_CER_RN2 */
+#define ACMD47              (0x40u|47u) /* SET_CER_RES2 */
+#define ACMD48              (0x40u|48u) /* GET_CER_RES1 */
+#define ACMD49              (0x40u|49u) /* CHANGE_SECURE_AREA */
+
+/* ==== Constants ==== */
+/* --- Command arg --- */
+#define ARG_ACMD6_1bit      (0)
+#define ARG_ACMD6_4bit      (2)
+
+/* ---- Response type  ---- */
+#define SD_RESP_NON         (0)         /* No response */
+#define SD_RESP_R1          (1)         /* Nomal response */
+#define SD_RESP_R1b         (2)         /* Nomal response with an optional busy signal */
+#define SD_RESP_R1_SCR      (3)         /* Nomal response with an optional busy signal */
+#define SD_RESP_R2_CID      (4)         /* CID register */
+#define SD_RESP_R2_CSD      (5)         /* CSD register */
+#define SD_RESP_R3          (6)         /* OCR register */
+#define SD_RESP_R6          (7)         /* Published RCA response */
+#define SD_RESP_R4          (8)         /* IO OCR register */
+#define SD_RESP_R5          (9)         /* IO RW response */
+#define SD_RESP_R7          (10)        /* Card Interface Condition response */
+
+/* --- R1 response error bit ---- */
+#define RES_SW_INTERNAL             (0xe8400000ul)  /* Driver illegal process */
+                                                    /* OUT_OF_RANGE */
+                                                    /* ADDRESS_ERROR */
+                                                    /* BLOCK_LEN_ERROR */
+                                                    /* ERASE_PARAM */
+                                                    /* RES_ILLEGAL_COMMAND */
+#define RES_ERASE_SEQ_ERROR         (0x10008000ul)  /* ERASE_SEQ_ERROR + WP_ERASE_SKIP */
+#define RES_WP_VIOLATION            (0x04000000ul)
+#define RES_CARD_IS_LOCKED          (0x02000000ul)
+#define RES_CARD_UNLOCKED_FAILED    (0x01000000ul)
+#define RES_COM_CRC_ERROR           (0x00800000ul)
+#define RES_CARD_ECC_FAILED         (0x00200000ul)
+#define RES_CC_ERROR                (0x00100000ul)
+#define RES_ERROR                   (0x00080000ul)
+#define RES_AKE_SEQ_ERROR           (0x00000008ul)
+#define RES_STATE                   (0x00001e00ul)
+
+/* --- Current_state --- */
+#define STATE_IDEL                  (0)
+#define STATE_READY                 (1u<<9u)
+#define STATE_IDENT                 (2u<<9u)
+#define STATE_STBY                  (3u<<9u)
+#define STATE_TRAN                  (4u<<9u)
+#define STATE_DATA                  (5u<<9u)
+#define STATE_RCV                   (6u<<9u)
+#define STATE_PRG                   (7u<<9u)
+#define STATE_DIS                   (8u<<9u)
+
+/* ---- Maximum block count per multiple command ---- */
+#define TRANS_SECTORS   (p_hndl->trans_sectors)   /* Max 65535 blocks */
+
+/* ---- Set block address, if HC card ---- */   /* @050805 for ver2.0 */
+#define SET_ACC_ADDR    ((p_hndl->csd_structure == 0x01) ? (psn) : (psn*512))
+
+/* ---- SD clock control ---- */
+#define SD_CLOCK_ENABLE             (1)         /* Supply clock */
+#define SD_CLOCK_DISABLE            (0)         /* Halt clock */
+
+/* ---- Info1 interrupt mask ---- */
+#define SD_INFO1_MASK_DET_DAT3      (0x0300u)   /* Card Insert and Remove (DAT3) */
+#define SD_INFO1_MASK_DET_CD        (0x0018u)   /* Card Insert and Remove (CD) */
+#define SD_INFO1_MASK_INS_DAT3      (0x0200u)   /* Card Insert (DAT3) */
+#define SD_INFO1_MASK_INS_CD        (0x0010u)   /* Card Insert (CD) */
+#define SD_INFO1_MASK_REM_DAT3      (0x0100u)   /* Card Remove (DAT3) */
+#define SD_INFO1_MASK_REM_CD        (0x0008u)   /* Card Remove (CD) */
+#define SD_INFO1_MASK_DATA_TRNS     (0x0004u)   /* Command sequence end */
+#define SD_INFO1_MASK_TRNS_RESP     (0x0005u)   /* Command sequence end and Response end */
+#define SD_INFO1_MASK_RESP          (0x0001u)   /* Response end */
+#define SD_INFO1_MASK_DET_DAT3_CD   (SD_INFO1_MASK_DET_DAT3|SD_INFO1_MASK_DET_CD)
+
+/* ---- Info2 interrupt mask ---- */
+#define SD_INFO2_MASK_BWE           (0x827fu)   /* Write enable and All errors */
+#define SD_INFO2_MASK_BRE           (0x817fu)   /* Read enable and All errors */
+#define SD_INFO2_MASK_ERR           (0x807fu)   /* All errors */
+#define SD_INFO2_MASK_ILA           (0x8000u)
+#define SD_INFO2_MASK_CBSY          (0x4000u)   /* Command type register busy */
+#define SD_INFO2_MASK_ERR6          (0x0040u)
+#define SD_INFO2_MASK_ERR5          (0x0020u)
+#define SD_INFO2_MASK_ERR4          (0x0010u)
+#define SD_INFO2_MASK_ERR3          (0x0008u)
+#define SD_INFO2_MASK_ERR2          (0x0004u)
+#define SD_INFO2_MASK_ERR1          (0x0002u)
+#define SD_INFO2_MASK_ERR0          (0x0001u)
+#define SD_INFO2_MASK_WE            (0x0200u)   /* Write enable */
+#define SD_INFO2_MASK_RE            (0x0100u)   /* Read enable */
+
+/* ---- Sdio_info interrupt mask ---- */
+#define SDIO_INFO1_MASK_EXWT        (0x8000u)
+#define SDIO_INFO1_MASK_EXPUB52     (0x4000u)
+#define SDIO_INFO1_MASK_IOIRQ       (0x0001u)   /* Interrupt from IO Card */
+
+/* ---- Ext_cd interrupt mask ---- */
+#define SD_EXT_CD_MASK_DET_P1       (0x0003u)
+#define SD_EXT_CD_MASK_DET_P2       (0x0018u)
+#define SD_EXT_CD_MASK_DET_P3       (0x00c0u)
+
+#define SD_EXT_CD_MASK_CD_P1        (0x0004u)
+#define SD_EXT_CD_MASK_CD_P2        (0x0020u)
+#define SD_EXT_CD_MASK_CD_P3        (0x0100u)
+
+
+/* ---- Sdio mode ---- */
+#define SDIO_MODE_C52PUB            (0x0200u)
+#define SDIO_MODE_IOABT             (0x0100u)
+#define SDIO_MODE_RWREQ             (0x0004u)
+#define SDIO_MODE_IOMOD             (0x0001u)   /* Interrupt from IO Card */
+
+/* ---- Cc extmode register ---- */
+#define CC_EXT_MODE_DMASDRW         (0x0002u)
+
+/* ---- Time out count ---- */
+#define SD_TIMEOUT_CMD              (100)       /* Commnad timeout */
+#define SD_TIMEOUT_MULTIPLE         (1000)      /* Block transfer timeout */
+#define SD_TIMEOUT_RESP             (1000)      /* Command sequence timeout */
+#define SD_TIMEOUT_DMA_END          (1000)      /* DMA transfer timeout */
+#define SD_TIMEOUT_ERASE_CMD        (10000)     /* Erase timeout */
+#define SD_TIMEOUT_PROG_CMD         (10000)     /* Programing timeout */
+
+/* ---- Data transafer direction ---- */
+#define SD_TRANS_READ               (0)         /* Host <- SD */
+#define SD_TRANS_WRITE              (1)         /* SD -> Host */
+
+/* ---- Card register size ---- */
+#define STATUS_DATA_BYTE            (64)        /* STATUS_DATA size */
+#define SD_STATUS_BYTE              (64)        /* SD STATUS size */
+#define SD_SCR_REGISTER_BYTE        (8)         /* SCR register size */
+
+/* ---- Area distinction ---- */
+#define SD_USER_AREA                (1u)
+#define SD_PROT_AREA                (2u)
+
+/* --- SD specification version ---- */
+#define SD_SPEC_10                  (0) /* SD physical spec 1.01 (phys spec ver1.01) */
+#define SD_SPEC_11                  (1) /* SD physical spec 1.10 (phys spec ver1.10) */
+#define SD_SPEC_20                  (2) /* SD physical spec 2.00 (phys spec ver2.00) */  /* @050805 for Ver2.0 */
+
+/* --- SD Card Speed ---- */
+#define SD_CUR_SPEED                (0x01u)     /* Current speed mode */
+#define SD_SUP_SPEED                (0x10u)     /* Supported speed mode */
+
+/* ---- Cc extmode register ---- */
+#define CC_EXT_MODE_DMASDRW         (0x0002u)
+
+/* ==== Format parameter ==== */
+#define SIZE_CARD_256KB             (256*1024/512)
+#define SIZE_CARD_1MB               (1024*1024/512)
+#define SIZE_CARD_2MB               (2*1024*1024/512)
+#define SIZE_CARD_4MB               (4*1024*1024/512)
+#define SIZE_CARD_8MB               (8*1024*1024/512)
+#define SIZE_CARD_16MB              (16*1024*1024/512)
+#define SIZE_CARD_32MB              (32*1024*1024/512)
+#define SIZE_CARD_64MB              (64*1024*1024/512)
+#define SIZE_CARD_128MB             (128*1024*1024/512)
+#define SIZE_CARD_256MB             (256*1024*1024/512)
+#define SIZE_CARD_504MB             (504*1024*1024/512)
+#define SIZE_CARD_1008MB            (1008*1024*1024/512)
+#define SIZE_CARD_1024MB            (1024*1024*1024/512)
+#define SIZE_CARD_2016MB            (2016*1024*1024/512)
+#define SIZE_CARD_2048MB            (2048ul*1024ul*1024ul/512ul)
+
+/* For FS ver2.0 */
+#define SIZE_CARD_4032MB            (4032ul*1024ul*2ul)
+#define SIZE_CARD_4096MB            (4096ul*1024ul*2ul)
+#define SIZE_CARD_8192MB            (8192ul*1024ul*2ul)
+#define SIZE_CARD_16384MB           (16384ul*1024ul*2ul)
+#define SIZE_CARD_32768MB           (32768ul*1024ul*2ul)
+
+#define NUM_HEAD_2                  (2)
+#define NUM_HEAD_4                  (4)
+#define NUM_HEAD_8                  (8)
+#define NUM_HEAD_16                 (16)
+#define NUM_HEAD_32                 (32)
+#define NUM_HEAD_64                 (64)
+#define NUM_HEAD_128                (128)
+
+/* For FS ver2.0 */
+#define NUM_HEAD_255                (255)
+
+#define SEC_PER_TRACK_16            (16)
+#define SEC_PER_TRACK_32            (32)
+#define SEC_PER_TRACK_63            (63)
+
+#define SEC_PER_CLUSTER_1           (1)
+#define SEC_PER_CLUSTER_2           (2)
+#define SEC_PER_CLUSTER_8           (8)
+#define SEC_PER_CLUSTER_16          (16)
+#define SEC_PER_CLUSTER_32          (32)
+#define SEC_PER_CLUSTER_64          (64)
+
+#define SIZE_OF_BU_1                (1)
+#define SIZE_OF_BU_2                (2)
+#define SIZE_OF_BU_8                (8)
+#define SIZE_OF_BU_16               (16)
+#define SIZE_OF_BU_32               (32)
+#define SIZE_OF_BU_64               (64)
+#define SIZE_OF_BU_128              (128)
+/* For FS ver2.0 */
+#define SIZE_OF_BU_8192             (8192)
+
+#define SD_SECTOR_SIZE              (512)
+
+/* For Phy Ver2.0 */
+/* Maximum AU size */
+#define SD_ERASE_SECTOR             ((4096*1024)/512)
+
+
+/* ==== Macro functions ==== */
+#define _sd_set_hndl(hndl)          (SDHandle[SDSelectPort] = (hndl))
+#define _sd_get_hndl()              (SDHandle[SDSelectPort])
+#define _sd_get_hndls(a)            (SDHandle[a])
+
+
+/* Fix function macro */
+#define sd_outp(h,offset,data)      (*(volatile uint64_t *)(_SDHI0_BASE_+(offset)) = (data))
+#define sd_inp(h,offset)            (*(volatile uint64_t *)(_SDHI0_BASE_+(offset)))
+
+#define sd_outp32(h,offset,data)    (*(volatile uint32_t *)(_SDHI0_BASE_+(offset)) = (uint32_t )(data))
+#define sd_inp32(h,offset)          (*(volatile uint32_t *)(_SDHI0_BASE_+(offset)))
+
+/* ---- System unique ---- */
+#define sd_set_fifo(h,data)
+
+#define _sd_card_send_cmd(hndl,cmd,resp)    (_sd_card_send_cmd_arg((hndl),(cmd),(resp),0,0))
+
+
+/* ==== Command type ==== */
+/* ---- eSD commands ---- */
+#define CMD43                       (0x052B)    /* SELECT_PARTITIONS */
+#define CMD44                       (0x0C2C)    /* MANAGE_PARTITIONS */
+#define CMD45                       (0x1C2D)    /* QUERY_PARTITIONS */
+
+/* ==== Constants ==== */
+#define SD_QUERY_PARTITION_LIST_BYTE    (512)
+#define SD_SPLIT_PARTITION_BYTE         (512)
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+/* ==== Encrypted device key structure ==== */
+/* ==== Format parameter structure ==== */
+typedef struct _chs_recom{
+    uint32_t    capa;
+    uint8_t     heads;
+    uint8_t     spt;
+}CHS_RECOM;
+
+typedef struct _scbu_recom{
+    uint32_t    capa;
+    uint8_t     sc;
+
+    /* For overflow */
+    uint16_t    bu;
+}SCBU_RECOM;
+
+/* ==== SD Driver work buffer (allocated by File system) ==== */
+/* Hide from users */
+/* ---- ""VAL DEF"" ---- */
+typedef struct __sdhndl{            /* SD handle */
+    uintptr_t   reg_base;               /* SDHI base address */
+    uint32_t    card_sector_size;       /* Sector size (user area) */
+    uint32_t    prot_sector_size;       /* Sector size (protect area) */
+    uint32_t    erase_sect;             /* Erase block size */
+    uint8_t     fat_type;               /* FAT type (FAT12:1 FAT16:2 FAT32:3 unknown:0)  */
+    uint8_t     csd_structure;          /* CSD structure (Standard capacity:0 High capacity:1) @050805 for ver2.0 */
+    uint8_t     csd_tran_speed;         /* CSD transfer speed */
+    uint16_t    csd_ccc;                /* CSD command class */
+    uint8_t     csd_copy;               /* CSD copy flag (not used) */
+    uint8_t     csd_file_format;        /* CSD file format group */
+    uint8_t     sd_spec;                /* SCR spec version (Ver1.0-1.01:0 Ver1.10:1) */
+    uint8_t     if_mode;                /* Bus width (1bit:0 4bits:1) */
+    uint8_t     speed_mode;             /* Card speed mode;
+                                           Current speed  : 0
+                                           Supported speed:0x10 */
+    /* For SD phy ver2.0 */
+    uint8_t     speed_class;            /* Card speed class */
+    uint8_t     perform_move;           /* Card move performance */
+
+    uint8_t     media_type;             /* Card type */
+    uint8_t     write_protect;          /* Write protect:     OFF : 0
+                                                           H/W WP : 1
+                                           CSD  TMP_WRITE_PROTECT : 2
+                                           CSD PERM_WRITE_PROTECT : 4
+                                           SD ROM                 : 0x10 */
+    uint8_t     io_flag;                /* Io initialize flag */
+                                        /* Interrupt enable       : bit4
+                                           Power on initialized   : bit2
+                                           Memory initialized     : bit1
+                                           Io func initialized    : bit0 */
+    uint8_t     io_info;                /* Io function's information */
+                                        /* Io ready               : bit7
+                                           Number of io func      : bit6-bit4
+                                           memory present         : bit3
+                                           Reserved               : bit2-bit0 */
+    uint16_t    int_info1;          /* SD_INFO1 status */
+    uint16_t    int_info2;          /* SD_INFO2 status */
+    uint16_t    int_info1_mask;     /* SD_INFO1_MASK status */
+    uint16_t    int_info2_mask;     /* SD_INFO2_MASK status */
+    uint16_t    int_io_info;        /* SDIO_INFO1 status */
+    uint16_t    int_io_info_mask;   /* SDIO_INFO1_MASK status */
+    uint32_t    voltage;            /* System supplied voltage */
+    int32_t     error;              /* Error detail information */
+    uint16_t    stop;               /* Compulsory stop flag */
+    uint8_t     mount;              /* Mount flag (unmount:0 mount:1) */
+    uint8_t     int_mode;           /* Interrupt flag detect method (polling:0 H/W interrupt:1) */
+    uint8_t     trans_mode;         /* Data transfer method  PIO : 0
+                                                      SD_BUF DMA : 0x2 */
+    uint8_t     sup_card;           /* Support card;
+                                                Memory (include MMC) : 0
+                                                                  IO : 1 */
+    uint8_t     sup_speed;          /* Support speed (Default:0 High-speed:1) */
+    uint8_t     sup_ver;            /* Support version (ver1.1:0 ver2.x:1) */
+    uint8_t     cd_port;            /* Card detect method (CD pin:0 DAT3:1) */
+    uint8_t     port;               /* Card port number */
+    int16_t     trans_sectors;      /* Maximum block counts per multiple command */
+    int32_t     (*int_cd_callback)(int32_t arg);     /* Callback function for card detection */
+    int32_t     (*int_format_callback)(int32_t arg); /* Callback function for card format */
+    int32_t     (*int_callback)(int32_t arg);        /* Callback function for interrupt flags */
+    int32_t     (*int_io_callback)(int32_t arg);     /* Callback function for interrupt flags */
+    int32_t     resp_status;        /* R1/R1b response status */
+    uint16_t    ocr[4/sizeof(uint16_t)];        /* OCR value */
+    uint16_t    io_ocr[4/sizeof(uint16_t)];     /* IO OCR value */
+    uint16_t    if_cond[4/sizeof(uint16_t)];    /* IF_COND value */    /* @050805 for ver2.0 */
+    uint16_t    cid[16/sizeof(uint16_t)];       /* CID value */
+    uint16_t    csd[16/sizeof(uint16_t)];       /* CSD value */
+    uint16_t    dsr[2/sizeof(uint16_t)];        /* DSR value */
+
+    /* @120807 Modified so that the head of array member is located on four byte boundary.  */
+    uint16_t    dummy1;
+
+    uint16_t    rca[4/sizeof(uint16_t)];           /* RCA value */
+    uint16_t    scr[8/sizeof(uint16_t)];           /* SCR value */
+    uint16_t    sdstatus[14/sizeof(uint16_t)];     /* SD STATUS value */
+
+    /* @120807  Modified so that the head of array member is located on four byte boundary.  */
+    uint16_t    dummy2;
+
+    uint16_t    status_data[18/sizeof(uint16_t)];  /* STATUS DATA value (phys spec ver1.10) */
+
+    /* @120807  Modified so that the head of array member is located on four byte boundary.  */
+    uint16_t    dummy3;
+
+    uint16_t    io_len[8];                         /* Io block length common:0 func:more than 1 */
+    uint8_t     io_reg[8][0x14/sizeof(uint8_t)];   /* CCCR(=0) and FBR(1 to 7) value */
+    uint8_t     cis[8][0x14/sizeof(uint8_t)];      /* CIS value (to be fixed) */
+    uint8_t     *rw_buff;                   /* Work buffer pointer */
+    uint32_t    buff_size;                  /* Work buffer size */
+
+    int32_t     partition_id;               /* Partition ID for eSD */
+}SDHNDL;
+/* ""VAL DEF END"" */
+
+/* ---- Variables used for format ---- */
+typedef struct _sd_format_param{
+    /* Format work buffer */
+    uint8_t  *pbuff;                /* Work buffer address */
+    uint32_t buff_sec_size;         /* Work buffer size (sector) */
+
+    /* Format parameter */
+    uint32_t    area_size;          /* Sectors per area(user/protect) */
+    uint32_t    format_size;        /* Number of format sectors */
+
+    uint16_t    fmt_spt;            /* Number of tracks */
+    uint16_t    fmt_hn;             /* Number of heads */
+    uint16_t    fmt_sc;             /* Sectors per cluster */
+    uint16_t    fmt_bu;             /* Boundary unit (sector) */
+
+    uint16_t    fmt_max;            /* Max cluster number */
+    uint16_t    fmt_sf;             /* Sectors per FAT
+                                          FAT12 and FAT16: BP22-BP23
+                                          FAT 32 : BP36-BP39
+                                    */
+
+    uint32_t    fmt_nom;            /* Sectors per MBR */
+    uint32_t    fmt_ssa;            /* Sectors per sysytem area */
+
+    uint8_t     fmt_fatbit;         /* FAT12, FAT16 or FAT32 */
+    /* For FS ver2.0 */
+    uint16_t    fmt_rsc;            /* Reserved sector count */
+
+    CHS_RECOM   *chs;
+    SCBU_RECOM  *scbu;
+    int32_t area;                       /* Format area */
+    /* Format write function */
+    int32_t (*write)(SDHNDL *hndl, struct _sd_format_param *sdfmt, uint8_t fill, uint32_t secno, int32_t seccnt,
+            int32_t (*callback)(uint32_t arg1, uint32_t arg2));
+    /* Format erase function  */
+    int32_t (*erase)(SDHNDL *hndl, struct _sd_format_param *sdfmt, uint32_t secno, int32_t seccnt,
+            int32_t (*callback)(uint32_t arg1, uint32_t arg2));
+}SD_FMT_WORK;
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+extern int32_t SDSelectPort;
+
+extern SDHNDL *SDHandle[NUM_PORT];
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+/* ---- sd_init.c ---- */
+extern int32_t _sd_init_hndl( SDHNDL *hndl, uint32_t mode, uint32_t voltage );
+extern int32_t _sd_select_port( SDHNDL *hndl, int32_t portno );
+
+/* ---- sd_mount.c ---- */
+extern int32_t _sd_card_init(SDHNDL *hndl);
+extern int32_t _sd_io_mount( SDHNDL *hndl);
+extern int32_t _sd_mem_mount(SDHNDL *hndl);
+extern int32_t _sd_set_io_speed(SDHNDL *hndl);
+extern int32_t _sd_set_mem_speed(SDHNDL *hndl);
+extern int32_t _sd_card_switch_func(SDHNDL *hndl, uint16_t h_arg,
+                                    uint16_t l_arg);
+extern int32_t _sd_card_get_status(SDHNDL *hndl);
+extern int32_t _sd_card_get_scr(SDHNDL *hndl);
+extern int32_t _sd_read_byte(SDHNDL *hndl, uint16_t cmd, uint16_t h_arg,
+                            uint16_t l_arg, uint8_t *readbuff, uint16_t byte);
+extern int32_t _sd_write_byte(SDHNDL *hndl, uint16_t cmd, uint16_t h_arg,
+                            uint16_t l_arg, uint8_t *writebuff, uint16_t byte);
+extern int32_t _sd_card_select_partition(SDHNDL *hndl, int32_t id);
+extern int32_t _esd_get_partition_id(SDHNDL *hndl, int32_t *id);
+
+/* ---- sd_trns.c ---- */
+extern int32_t _sd_software_trans(SDHNDL *hndl, uint8_t *buff, uint32_t cnt, int32_t dir);
+extern int32_t _sd_dma_trans(SDHNDL *hndl, uint32_t cnt);
+
+/* ---- sd_read.c ---- */
+/* No function */
+
+/* ---- sd_write.c ---- */
+extern int32_t _sd_write_sect(SDHNDL *hndl, uint8_t *buff, uint32_t psn,
+        int32_t cnt, int32_t writemode);
+
+/* ---- sd_io_read.c ---- */
+extern int32_t _sdio_read(SDHNDL *hndl, uint8_t *buff, uint32_t func,
+                            uintptr_t adr, int32_t cnt, uint32_t op_code);
+
+/* ---- sd_io_write.c ---- */
+extern int32_t _sdio_write(SDHNDL *hndl, uint8_t *buff, uint32_t func,
+                            uintptr_t adr, int32_t cnt, uint32_t op_code);
+
+/* ---- sd_io_direct.c ---- */
+extern int32_t _sdio_direct(SDHNDL *hndl, uint8_t *buff, uint32_t func,
+                            uintptr_t adr, uint32_t rw_flag, uint32_t raw_flag);
+
+/* ---- sd_cd.c ---- */
+extern int32_t _sd_check_media(SDHNDL *hndl);
+extern int32_t _sd_get_ext_cd_int(SDHNDL *hndl);
+
+/* ---- sd_cmd.c ---- */
+extern int32_t _sd_send_cmd( SDHNDL *hndl, uint16_t cmd);
+extern int32_t _sd_send_acmd(SDHNDL *hndl, uint16_t cmd, uint16_t h_arg, uint16_t l_arg);
+extern int32_t _sd_send_mcmd(SDHNDL *hndl, uint16_t cmd, uint32_t startaddr);
+extern int32_t _sd_card_send_cmd_arg(SDHNDL *hndl, uint16_t cmd, int32_t resp, uint16_t h_arg, uint16_t l_arg);
+extern void _sd_set_arg(SDHNDL *hndl, uint16_t h_arg, uint16_t l_arg);
+extern int32_t _sd_card_send_ocr(SDHNDL *hndl, int32_t type);
+extern int32_t _sd_check_resp_error(SDHNDL *hndl);
+extern int32_t _sd_get_resp( SDHNDL *hndl, int32_t resp);
+extern int32_t _sd_check_csd(SDHNDL *hndl);
+extern int32_t _sd_check_info2_err(SDHNDL *hndl);
+extern int32_t _sd_send_iocmd(SDHNDL *hndl, uint16_t cmd, uint32_t arg);
+
+/* ---- sd_int.c ---- */
+extern int32_t    _sd_set_int_mask(  SDHNDL *hndl, uint16_t mask1, uint16_t mask2);
+extern int32_t    _sd_clear_int_mask(SDHNDL *hndl, uint16_t mask1, uint16_t mask2);
+extern int32_t _sd_get_int(SDHNDL *hndl);
+extern int32_t _sd_clear_info(SDHNDL *hndl, uint16_t clear_info1,  uint16_t clear_info2);
+
+/* ---- sdio_int.c ---- */
+extern int32_t _sdio_set_int_mask(  SDHNDL *hndl, uint16_t mask);
+extern int32_t _sdio_clear_int_mask(SDHNDL *hndl, uint16_t mask);
+extern int32_t _sdio_clear_info(SDHNDL *hndl, uint16_t clear);
+extern int32_t _sdio_get_int(SDHNDL *hndl);
+
+/* ---- sd_util.c ---- */
+extern int32_t _sd_set_clock(SDHNDL *hndl, int32_t clock, int32_t enable);
+extern int32_t _sd_set_port( SDHNDL *hndl, int32_t port);
+extern int32_t _sd_iswp(SDHNDL *hndl);
+extern int32_t _sd_set_err(SDHNDL *hndl,   int32_t error);
+extern int32_t _sd_bit_search(uint16_t data);
+extern int32_t _sd_get_size(SDHNDL *hndl, uint32_t area);
+extern int32_t _sd_standby( SDHNDL *hndl);
+extern int32_t _sd_active(  SDHNDL *hndl);
+extern int32_t _sd_inactive(SDHNDL *hndl);
+extern int32_t _sdio_set_blocklen(SDHNDL *hndl, uint16_t len, uint8_t func);
+extern int32_t _sd_memset(uint8_t *p,   uint8_t data, uint32_t cnt);
+extern int32_t _sd_memcpy(uint8_t *dst, uint8_t *src, uint32_t cnt);
+extern uint16_t _sd_rand(void);
+extern void _sd_srand(uint32_t seed);
+
+/* ---- sd_format.c ---- */
+extern int32_t _sd_format(SDHNDL *hndl,SD_FMT_WORK *sdfmt, int32_t format_mode,
+        int32_t (*callback)(uint32_t arg1, uint32_t arg2));
+extern int32_t _sd_wait_rbusy(SDHNDL *hndl, int32_t time);
+
+/* ---- sd_mount.c ---- */
+extern int32_t _sd_calc_erase_sector(SDHNDL *hndl);
+
+#endif    /* SD_H */
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_cd.c b/plat/renesas/rz/common/drivers/sd/sd_cd.c
new file mode 100644
index 000000000..78dcfa23f
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_cd.c
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_cd.c
+ * Version      : 1.0
+ * Description  : Card detect.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"
+#include "sys_sel.h"
+#include "sd.h"
+#include "ut_define.h"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#define EXT_CD_REM    (0x0001)
+#define EXT_CD_INS    (0x0002)
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+
+
+
+/**********************************************************************************************************************
+ * Function Name: esd_check_media
+ * Description  : check card insertion
+ *              : if card is inserted, return SD_OK
+ *              : if card is not inserted, return SD_ERR
+ *              : if SD handle is not initialized, return SD_ERR
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_OK : card is inserted
+ *              : SD_ERR: card is not inserted
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_check_media(void)
+{
+    SDHNDL    *p_hndl;
+
+    p_hndl = _sd_get_hndl();
+    if(p_hndl == 0)
+    {
+        return SD_ERR;    /* Not initialized */
+    }
+    
+    return _sd_check_media(p_hndl);
+}
+/**********************************************************************************************************************
+ * End of function esd_check_media
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_check_media
+ * Description  : check card insertion
+ *              : if card is inserted, return SD_OK
+ *              : if card is not inserted, return SD_ERR
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_OK : card is inserted
+ *              : SD_ERR: card is not inserted
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_check_media(SDHNDL *hndl)
+{
+    return SD_OK;    /* Inserted */
+}
+/**********************************************************************************************************************
+ * End of function _sd_check_media
+ *********************************************************************************************************************/
+
+
+/**********************************************************************************************************************
+ * Function Name: _sd_get_ext_cd_int
+ * Description  : Check&Get Port1-3 Card Ins&Rem Interrupt request.
+ * Arguments    : SDHNDL *hndl   ; SD driver handle
+ * Return Value : != 0 : interrupt ocurred
+ *              : == 0 : interrupt not ocurred
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_get_ext_cd_int(SDHNDL *hndl)
+{
+    uint16_t reg;
+    uint16_t sift;
+    uint16_t info;
+    
+    if(hndl->port == 0)
+    {
+        return SD_ERR;
+    }
+    sift = (uint16_t)((hndl->port - 1)*3);
+    info = 0;
+    
+    reg = sd_inp(hndl,EXT_CD_MASK);
+    reg = (uint16_t)(sd_inp(hndl,EXT_CD) & (~reg));
+
+    sd_outp(hndl,EXT_CD,(uint16_t)~reg);
+    
+    reg >>= sift;
+    
+    if(reg & EXT_CD_REM)
+    {
+        info |= SD_INFO1_MASK_REM_CD;
+    }
+    else if(reg & EXT_CD_INS)
+    {
+        info |= SD_INFO1_MASK_INS_CD;
+    }
+    else
+    {
+        ; /* DO NOTHING */
+    }
+
+    reg = sd_inp(hndl,EXT_CD_DAT3_MASK);
+    reg = (uint16_t)(sd_inp(hndl,EXT_CD_DAT3) & (~reg));
+
+    sd_outp(hndl,EXT_CD_DAT3,(uint16_t)~reg);
+    
+    reg >>= sift;
+    
+    if(reg & EXT_CD_REM)
+    {
+        info |= SD_INFO1_MASK_REM_DAT3;
+    }
+    else if(reg & EXT_CD_INS)
+    {
+        info |= SD_INFO1_MASK_INS_DAT3;
+    }
+    else
+    {
+        ; /* DO NOTHING */
+    }
+    
+    hndl->int_info1 &= (uint16_t)~SD_INFO1_MASK_DET_DAT3_CD;
+    
+    hndl->int_info1 |= info;
+
+    return (int32_t)info;
+}
+/**********************************************************************************************************************
+ * End of function _sd_get_ext_cd_int
+ *********************************************************************************************************************/
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_cmd.c b/plat/renesas/rz/common/drivers/sd/sd_cmd.c
new file mode 100644
index 000000000..58e6b98e0
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_cmd.c
@@ -0,0 +1,802 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_cmd.c
+ * Version      : 1.0
+ * Description  : command issue, response receive and register check.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"
+#include "sys_sel.h"
+#include "sd.h"
+#include "ut_define.h"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+/* ==== Response errors ==== */
+/* For internal error detail    */
+static const int32_t RespErrTbl[]={
+    SD_ERR_OUT_OF_RANGE,
+    SD_ERR_ADDRESS_ERROR,
+    SD_ERR_BLOCK_LEN_ERROR,
+    SD_ERR_CARD_ERASE,
+    SD_ERR_CARD_ERASE,
+    SD_ERR_WP,
+    SD_ERR_CARD_LOCK,
+    SD_ERR_CARD_UNLOCK,
+    SD_ERR_HOST_CRC,
+    SD_ERR_ILLEGAL_COMMAND,
+    SD_ERR_CARD_ECC,
+    SD_ERR_CARD_CC,
+    SD_ERR_CARD_ERROR,
+    SD_ERR_RESERVED_ERROR18,
+    SD_ERR_RESERVED_ERROR17,
+    SD_ERR_OVERWRITE,
+};
+
+/* ==== IO errors ==== */
+static const int32_t IOErrTbl[]={
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_HOST_CRC,
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_INTERNAL,
+    SD_ERR_CARD_ERROR,
+    SD_ERR_INTERNAL,
+    SD_ERR_ILL_FUNC,
+    SD_ERR_INTERNAL,
+};
+
+/* ==== SD_INFO2 errors table ==== */
+
+
+        /* For internal error detail    */
+static const int32_t Info2ErrTbl[]={
+    SD_ERR_RES_TOE,        /* SD_INFO2_MASK_ERR6    0x0040 */
+    SD_ERR_ILL_READ,    /* SD_INFO2_MASK_ERR5    0x0020 */
+    SD_ERR_ILL_WRITE,    /* SD_INFO2_MASK_ERR4    0x0010 */
+    SD_ERR_CARD_TOE,    /* SD_INFO2_MASK_ERR3    0x0008 */
+    SD_ERR_END_BIT,        /* SD_INFO2_MASK_ERR2    0x0004 */
+    SD_ERR_CRC,            /* SD_INFO2_MASK_ERR1    0x0002 */
+    SD_ERR_CMD_ERROR,    /* SD_INFO2_MASK_ERR0    0x0001 */
+};
+
+
+/* ==== Transfer speed table ==== */
+static const uint16_t TranSpeed[8]={
+    1,        /* 100kbit/s */
+    10,        /* 1Mbit/s   */
+    100,    /* 10Mbit/s  */
+    1000,    /* 100Mbit/s */
+    1000,    /* reserved  */
+    1000,    /* reserved  */
+    1000,    /* reserved  */
+    1000,    /* reserved  */
+};
+static const uint8_t TimeValue[16]={
+    0,10,12,13,15,20,25,30,35,40,45,50,55,60,70,80
+};
+
+SD_DRV_CODE_SEC static void _sd_get_info2(SDHNDL *hndl);
+
+/**********************************************************************************************************************
+ * Function Name: _sd_send_cmd
+ * Description  : issue SD command, hearafter wait recive response.
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t cmd : command code
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : not get response and check response errors
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_send_cmd(SDHNDL *hndl, uint16_t cmd)
+{
+    int32_t time;
+    
+    hndl->error = SD_OK;
+
+    if(cmd == CMD38)
+    {    /* Erase command */
+        time = SD_TIMEOUT_ERASE_CMD;    /* Extend timeout 1 sec */
+    }
+    else if(cmd == ACMD46)
+    {    /* ACMD46 */
+        time = SD_TIMEOUT_MULTIPLE;    /* Same as write timeout */
+    }
+    /* @090106 R1b command lengthens timeout time*/
+    else if(cmd == CMD7)
+    {
+        time = SD_TIMEOUT_RESP;    /* Same as write timeout */
+    }
+    else if(cmd == CMD12)
+    {
+        time = SD_TIMEOUT_RESP;    /* Same as write timeout */
+    }
+
+    /* eSD Addendum Version 2.10 to Part 1 Physical Layer Specifications  */
+    /* Refer "2.4.6.1 SELECT_PARTITION (CMD43)" */
+    /* Adjusted to the physical partition area that is not FAST_BOOT attribute */
+    else if(cmd == CMD43)
+    {
+        time = SD_TIMEOUT_RESP;
+    }
+    else if(cmd == CMD45)
+    {
+        time = SD_TIMEOUT_RESP;
+    }
+    else
+    {
+        time = SD_TIMEOUT_CMD;
+    }
+    
+    /* Enable resp end and illegal access interrupts */
+    _sd_set_int_mask(hndl,SD_INFO1_MASK_RESP,0);
+
+    /* ---- Issue command ---- */
+
+    sd_outp32(hndl,SD_CMD,cmd);
+    
+    /* ---- Wait resp end ---- */
+    if(esddev_int_wait(time) != SD_OK)
+    {
+        _sd_set_err(hndl,SD_ERR_HOST_TOE);
+        _sd_clear_int_mask(hndl,SD_INFO1_MASK_RESP,SD_INFO2_MASK_ILA);
+        return hndl->error;
+    }
+
+    /* Disable resp end and illegal access interrupts */
+    _sd_clear_int_mask(hndl,SD_INFO1_MASK_RESP,SD_INFO2_MASK_ILA);
+
+    _sd_get_info2(hndl);    /* Get SD_INFO2 register */
+
+    _sd_check_info2_err(hndl);    /* Check SD_INFO2 error bits */
+
+    if(!(hndl->int_info1 & SD_INFO1_MASK_RESP))
+    {
+        /* For internal error detail    */
+        _sd_set_err(hndl,SD_ERR_NO_RESP_ERROR);        /* No response */
+    }
+
+    /* ---- Clear previous errors ---- */
+    _sd_clear_info(hndl,SD_INFO1_MASK_RESP,SD_INFO2_MASK_ERR);
+
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_send_cmd
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_send_acmd
+ * Description  : issue application specific command, hearafter wait recive response
+ *              : issue CMD55 preceide application specific command
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t cmd : command code
+ *              : uint16_t h_arg : command argument high [31:16]
+ *              : uint16_t l_arg : command argument low [15:0]
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_send_acmd(SDHNDL *hndl, uint16_t cmd, uint16_t h_arg,
+        uint16_t l_arg)
+{
+    /* ---- Issue CMD 55 ---- */
+    _sd_set_arg(hndl,hndl->rca[0],0);
+    if(_sd_send_cmd(hndl, CMD55) != SD_OK)
+    {
+        return SD_ERR;
+    }
+    
+    if(_sd_get_resp(hndl,SD_RESP_R1) != SD_OK)
+    {
+        return SD_ERR;
+    }
+    
+    /* ---- Issue ACMD ---- */
+    _sd_set_arg(hndl,h_arg,l_arg);
+    if(_sd_send_cmd(hndl, cmd) != SD_OK)
+    {
+        return SD_ERR;
+    }
+    
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_send_acmd
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_send_mcmd
+ * Description  : issue multiple command (CMD18 or CMD25)
+ *              : wait response
+ *              : set read start address to startaddr
+ *              : after this function finished, start data transfer
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t cmd : command code (CMD18 or CMD25)
+ *              : uint32_t startaddr : data address (command argument)
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_send_mcmd(SDHNDL *hndl, uint16_t cmd, uint32_t startaddr)
+{
+    _sd_set_arg(hndl,(uint16_t)(startaddr>>16),(uint16_t)startaddr);
+    /* ---- Issue command ---- */
+    sd_outp32(hndl,SD_CMD,cmd);
+
+    /* ---- Wait resp end ---- */
+    if(esddev_int_wait(SD_TIMEOUT_CMD) != SD_OK)
+    {
+        _sd_set_err(hndl,SD_ERR_HOST_TOE);
+        return hndl->error;
+    }
+
+    _sd_get_info2(hndl);    /* Get SD_INFO2 register */
+
+    _sd_check_info2_err(hndl);    /* Check SD_INFO2 error bits */
+
+    if(hndl->int_info1 & SD_INFO1_MASK_RESP)
+    {
+        if(!hndl->error)
+        {
+            _sd_get_resp(hndl,SD_RESP_R1);    /* Check R1 resp */
+        }
+    }
+    else
+    {
+        /* For internal error detail    */
+        _sd_set_err(hndl,SD_ERR_NO_RESP_ERROR);        /* No response */
+    }
+
+    /* ---- Clear previous errors ---- */
+    _sd_clear_info(hndl,SD_INFO1_MASK_RESP,SD_INFO2_MASK_ERR);
+
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_send_mcmd
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_card_send_cmd_arg
+ * Description  : issue command specified cmd code
+ *              : get and check response
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t cmd : command code (CMD18 or CMD25)
+ *              : int32_t  resp : command response
+ *              : uint16_t h_arg : command argument high [31:16]
+ *              : uint16_t l_arg : command argument low [15:0]
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : if argument value is zero,
+ *              : use macro function, that is _sd_card_send_cmd()
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_card_send_cmd_arg(SDHNDL *hndl, uint16_t cmd, int32_t resp,
+        uint16_t h_arg, uint16_t l_arg)
+{
+    int32_t ret;
+
+    _sd_set_arg(hndl,h_arg,l_arg);
+    
+    /* ---- Issue command ---- */
+    if((ret =_sd_send_cmd(hndl,cmd)) == SD_OK)
+    {
+        ret = _sd_get_resp(hndl,resp);    /* get and check response */
+    }
+    return ret;
+}
+/**********************************************************************************************************************
+ * End of function _sd_card_send_cmd_arg
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_set_arg
+ * Description  : set command argument to SDHI
+ *              : h_arg means higher 16bits [31:16] and  set SD_ARG0
+ *              : l_arg means lower 16bits [15:0] and set SD_ARG1
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t h_arg : command argument high [31:16]
+ *              : uint16_t l_arg : command argument low [15:0]
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : SD_ARG0 and SD_ARG1 are like little endian order
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC void _sd_set_arg(SDHNDL *hndl, uint16_t h_arg, uint16_t l_arg)
+{
+    sd_outp(hndl,SD_ARG0,l_arg);
+    sd_outp(hndl,SD_ARG1,h_arg);
+}
+/**********************************************************************************************************************
+ * End of function _sd_set_arg
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_card_send_ocr
+ * Description  : get OCR register and check card operation voltage
+ *              : if type is SD_MEDIA_SD, issue ACMD41
+ *              : if type is SD_MEDIA_MMC, issue CMD1
+ *              : if type is SD_MEDIA_IO, issue CMD5
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : int32_t type : card type
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_card_send_ocr(SDHNDL *hndl, int32_t type)
+{
+    int32_t ret;
+    int32_t i;
+    int32_t j=0;
+
+    /* ===== Distinguish card type issuing CMD5, ACMD41 or CMD1 ==== */
+    for(i=0; i < 200; i++)
+    {
+        switch(type)
+        {
+            case SD_MEDIA_UNKNOWN:    /* Unknown media (read OCR) */
+                /* ---- Issue CMD5 ---- */
+                _sd_set_arg(hndl,0,0);
+                ret = _sd_send_cmd(hndl,CMD5);
+                if(ret == SD_OK)
+                {
+                    return _sd_get_resp(hndl,SD_RESP_R4);    /* check R4 resp */
+                }
+                else
+                {
+                    return ret;
+                }
+
+            case SD_MEDIA_IO:
+                /* ---- Issue CMD5 ---- */
+                _sd_set_arg(hndl,(uint16_t)(hndl->voltage>>16),
+                    (uint16_t)hndl->voltage);
+                ret = _sd_send_cmd(hndl,CMD5);
+                break;
+        
+            case SD_MEDIA_SD:
+            case SD_MEDIA_COMBO:
+                if(hndl->sup_ver == SD_MODE_VER2X)
+                {
+                    /* Set HCS bit */
+                    hndl->voltage |= 0x40000000;
+                }
+                /* ---- Issue ACMD41 ---- */
+                ret = _sd_send_acmd(hndl,ACMD41,
+                    (uint16_t)(hndl->voltage>>16),
+                    (uint16_t)hndl->voltage);
+                break;
+        
+            case SD_MEDIA_MMC:    /* MMC */
+                /* ---- Issue CMD1 ---- */
+                _sd_set_arg(hndl,(uint16_t)(hndl->voltage>>16),
+                    (uint16_t)hndl->voltage);
+                ret = _sd_send_cmd(hndl,CMD1);
+                break;
+
+            default:
+                hndl->resp_status = 0;
+                /* For internal error detail    */
+                /* But not need to change        */
+                hndl->error = SD_ERR_INTERNAL;
+                return SD_ERR;
+        }
+        
+        if(ret == SD_OK)
+        {
+            if(type == SD_MEDIA_IO)
+            {    /* IO */
+                _sd_get_resp(hndl,SD_RESP_R4);    /* Check R4 resp */
+                /* ---- Polling busy bit ---- */
+                if(hndl->io_ocr[0] & 0x8000)
+                {    /* Busy cleared */
+                    break;
+                }
+                else
+                {
+                    ret = SD_ERR;    /* Busy */
+                    esddev_int_wait(5);    /* Add wait function because retry interval is too short */
+                }
+            }
+            else
+            {    /* Memory */
+                _sd_get_resp(hndl,SD_RESP_R3);    /* Check R3 resp */
+                /* ---- Polling busy bit ---- */
+                if(hndl->ocr[0] & 0x8000)
+                {    /* Busy cleared */
+                    break;
+                }
+                else
+                {
+                    ret = SD_ERR;    /* Busy */
+                    esddev_int_wait(5);    /* Add wait function because retry interval is too short */
+                }
+            }
+        }
+        
+        /* If more than 3 times response timeout occured, retry stop quick distinction to MMC */ 
+        if(hndl->error == SD_ERR_RES_TOE)
+        {
+            ++j;
+            if( j == 3)
+            {
+                break;
+            }
+        }
+        else
+        {
+            j = 0;
+        } 
+    }
+    return ret;
+}
+/**********************************************************************************************************************
+ * End of function _sd_card_send_ocr
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_check_resp_error
+ * Description  : distinguish error bit from R1 response
+ *              : set the error bit to hndl->error
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_OK : no error detected
+ *              : SD_ERR: any errors detected
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_check_resp_error(SDHNDL *hndl)
+{
+    uint16_t status;
+    int32_t bit;
+    
+
+    if(hndl->media_type == SD_MEDIA_IO)
+    {
+        /* IO */
+        status = (uint16_t)(hndl->resp_status & 0xfff9u);
+
+        /* Serch R5 error bit */
+        bit = _sd_bit_search(status);
+        
+        /* R5 resp errors bits */
+        _sd_set_err(hndl,IOErrTbl[bit]);
+    }
+    else
+    {
+        /* SD or MMC card */
+        status = (uint16_t)((hndl->resp_status >>16 ) & 0xfff9u);
+        
+        /* ---- Search R1 error bit ---- */
+        bit = _sd_bit_search(status);
+        
+        if(bit != (-1))
+        {
+            /* R1 resp errors bits but for AKE_SEQ_ERROR */
+            _sd_set_err(hndl,RespErrTbl[bit]);
+            return SD_ERR;
+        }
+        else if(hndl->resp_status & RES_AKE_SEQ_ERROR)
+        {
+            /* Authentication process sequence error */
+            _sd_set_err(hndl,SD_ERR_AKE_SEQ);
+            return SD_ERR;
+        }
+        else
+        {
+            /* No operation */
+        }
+    }
+    
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_check_resp_error
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_get_resp
+ * Description  : get response value from RESP register
+ *              : R1, R2, R3,(R4, R5) and R6 types are available
+ *              : specify response type by the argument resp
+ *              : set response value to SD handle member
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : int32_t resp : response type
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_get_resp(SDHNDL *hndl, int32_t resp)
+{
+    uint32_t status;
+    uint16_t *p_ptr;
+    
+    /* Select RESP register depend on the response type */
+    switch(resp)
+    {
+        case SD_RESP_NON:    /* No response */
+            /* NOP */
+            break;
+        case SD_RESP_R1:    /* Nomal response (32bits length) */
+        case SD_RESP_R1b:    /* Nomal response with an optional busy signal */
+            status = sd_inp(hndl,SD_RESP1);
+            status <<=16;
+            status |= sd_inp(hndl,SD_RESP0);
+            hndl->resp_status = status;
+        
+            if(status & 0xffffe008)
+            {
+                /* Any status error */
+                return _sd_check_resp_error(hndl);
+            }
+            break;
+        
+        case SD_RESP_R1_SCR:    /* Nomal response with an optional busy signal */
+            hndl->scr[0] = sd_inp(hndl,SD_RESP1);
+            hndl->scr[1] = sd_inp(hndl,SD_RESP0);
+            break;
+        
+        case SD_RESP_R2_CID:    /* CID register (128bits length) */
+            p_ptr = hndl->cid;
+            *p_ptr++ = sd_inp(hndl,SD_RESP7);
+            *p_ptr++ = sd_inp(hndl,SD_RESP6);
+            *p_ptr++ = sd_inp(hndl,SD_RESP5);
+            *p_ptr++ = sd_inp(hndl,SD_RESP4);
+            *p_ptr++ = sd_inp(hndl,SD_RESP3);
+            *p_ptr++ = sd_inp(hndl,SD_RESP2);
+            *p_ptr++ = sd_inp(hndl,SD_RESP1);
+            *p_ptr++ = sd_inp(hndl,SD_RESP0);
+            break;
+        
+        case SD_RESP_R2_CSD:    /* CSD register (128bits length) */
+            p_ptr = hndl->csd;
+            *p_ptr++ = sd_inp(hndl,SD_RESP7);
+            *p_ptr++ = sd_inp(hndl,SD_RESP6);
+            *p_ptr++ = sd_inp(hndl,SD_RESP5);
+            *p_ptr++ = sd_inp(hndl,SD_RESP4);
+            *p_ptr++ = sd_inp(hndl,SD_RESP3);
+            *p_ptr++ = sd_inp(hndl,SD_RESP2);
+            *p_ptr++ = sd_inp(hndl,SD_RESP1);
+            *p_ptr++ = sd_inp(hndl,SD_RESP0);
+            break;
+        
+        case SD_RESP_R3:    /* OCR register (32bits length) */
+            hndl->ocr[0] = sd_inp(hndl,SD_RESP1);
+            hndl->ocr[1] = sd_inp(hndl,SD_RESP0);
+            break;
+
+        case SD_RESP_R4:    /* IO OCR register (24bits length) */
+            hndl->io_ocr[0] = sd_inp(hndl,SD_RESP1);
+            hndl->io_ocr[1] = sd_inp(hndl,SD_RESP0);
+            break;
+        
+        case SD_RESP_R6:        /* Published RCA response (32bits length) */
+            hndl->rca[0] = sd_inp(hndl,SD_RESP1);
+            hndl->rca[1] = sd_inp(hndl,SD_RESP0);
+            break;
+        
+        case SD_RESP_R5:        /* IO RW response */
+            status = sd_inp(hndl,SD_RESP1);
+            status <<=16;
+            status |= sd_inp(hndl,SD_RESP0);
+            hndl->resp_status = status;
+        
+            if(status & 0xcb00)
+            {
+                /* Any status error */
+                return _sd_check_resp_error(hndl);
+            }
+            break;
+
+        /* @050805 for Ver2.0 */
+        case SD_RESP_R7:        /* IF_COND response */
+            hndl->if_cond[0] = sd_inp(hndl,SD_RESP1);
+            hndl->if_cond[1] = sd_inp(hndl,SD_RESP0);
+            break;
+    
+        default:
+            /* Unknown type */
+            hndl->resp_status = 0;
+            /* For internal error detail    */
+            /* But not need to change        */
+            hndl->error = SD_ERR_INTERNAL;
+            return SD_ERR;
+    }
+    
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_get_resp
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_check_csd
+ * Description  : check CSD register and get following information
+ *              : Transfer Speed
+ *              : Command Class
+ *              : Read Block Length
+ *              : Copy Bit
+ *              : Write Protect Bit
+ *              : File Format Group
+ *              : Number of Erase Sector
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_check_csd(SDHNDL *hndl)
+{
+    uint32_t transpeed;
+    uint32_t timevalue;
+    uint32_t erase_sector_size;
+    uint32_t erase_group_size;
+
+    /* ---- CSD Structure ---- */    /* For Ver2.0 */
+
+    if(hndl->media_type == SD_MEDIA_MMC)
+    {
+        hndl->csd_structure = 0;
+    }
+    else
+    {
+        hndl->csd_structure = (uint8_t)((hndl->csd[0] & 0x00c0u) >> 6u);
+    }
+    
+    /* ---- TAAC/NSAC ---- */
+    /* No check, to be obsolete */
+
+    /* ---- TRAN_SPEED  ---- */
+    transpeed = (hndl->csd[2] & 0x0700u) >> 8u;
+    timevalue = (hndl->csd[2] & 0x7800u) >> 11u;
+    
+    transpeed = (uint32_t)(TranSpeed[transpeed] * TimeValue[timevalue]);
+    
+    /* ---- Set transfer speed (memory access) ---- */
+    if(transpeed >= 5000)
+    {
+        hndl->csd_tran_speed = SD_CLK_50MHz;
+    }
+    else if(transpeed >= 2500)
+    {
+        hndl->csd_tran_speed = SD_CLK_25MHz;
+    }
+    else if(transpeed >= 2000)
+    {
+        hndl->csd_tran_speed = SD_CLK_20MHz;
+    }
+    else if(transpeed >= 1000)
+    {
+        hndl->csd_tran_speed = SD_CLK_10MHz;
+    }
+    else if(transpeed >= 500)
+    {
+        hndl->csd_tran_speed = SD_CLK_5MHz;
+    }
+    else if(transpeed >= 100)
+    {
+        hndl->csd_tran_speed = SD_CLK_1MHz;
+    }
+    else
+    {
+        hndl->csd_tran_speed = SD_CLK_400kHz;
+    }
+    
+    /* ---- CCC  ---- */
+    hndl->csd_ccc = (uint16_t)(((hndl->csd[2] & 0x00ffu) << 4u) |
+        ((hndl->csd[3] & 0xf000u) >> 12u));
+    
+    
+    /* ---- COPY ---- */
+    hndl->csd_copy = (uint8_t)(hndl->csd[7] & 0x0040u);
+    
+    /* ---- PERM/TMP_WRITE_PROTECT ---- */
+    hndl->write_protect |= (uint8_t)((hndl->csd[7] & 0x0030u)>>3u);
+    
+    /* ---- FILE_FORMAT ---- */
+    hndl->csd_file_format = (uint8_t)(hndl->csd[7] & 0x008cu);
+    if(hndl->csd_file_format & 0x80u)
+    {
+        _sd_set_err(hndl, SD_ERR_FILE_FORMAT);
+        return SD_ERR;
+    }
+    
+    /* ---- Calculate the number of erase sectors ---- */
+    if(hndl->media_type & SD_MEDIA_SD)
+    {
+        erase_sector_size = ((hndl->csd[5] & 0x003fu) << 1u) | 
+            ((hndl->csd[6] & 0x8000) >> 15);
+        erase_group_size = (hndl->csd[6] & 0x7f00u) >> 8u; 
+    }
+    else
+    {
+        erase_sector_size = (hndl->csd[5] & 0x007cu) >> 2u;
+        erase_group_size = ((hndl->csd[5] & 0x0003u) << 3u) | 
+            ((hndl->csd[6] & 0xe000u) >> 13u); 
+    }
+    hndl->erase_sect = (erase_sector_size+1) * (erase_group_size+1);
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_check_csd
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_check_info2_err
+ * Description  : check error bit of SD_INFO2 register
+ *              : set the error bit to hndl->error
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_OK : end of succeed
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_check_info2_err(SDHNDL *hndl)
+{
+    uint16_t info2;
+    int32_t bit;
+    
+    info2 = (uint16_t)(hndl->int_info2 & SD_INFO2_MASK_ERR);
+    
+    /* ---- Search error bit ---- */
+    bit = _sd_bit_search(info2);
+    
+    if(bit == (-1))
+    {    /* No error */
+        _sd_set_err(hndl,SD_OK);
+    }
+    else if(bit == 0)
+    {    /* CMD error */
+        /* For internal error detail    */
+        _sd_set_err(hndl,SD_ERR_CMD_ERROR);
+    }
+    else
+    {    /* Other error */
+        _sd_set_err(hndl,Info2ErrTbl[bit-9]);
+    }
+    
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_check_info2_err
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_get_info2
+ * Description  : get SD_INFO2 register
+ *              : set the register value to hndl->int_info2
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : none.
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC static void _sd_get_info2(SDHNDL *hndl)
+{
+    uint16_t info2_reg;
+
+    info2_reg = (uint16_t)((sd_inp(hndl,SD_INFO2) & SD_INFO2_MASK_ERR));
+    sd_outp(hndl,SD_INFO2,(uint16_t)~info2_reg);
+    hndl->int_info2 = (uint16_t)(hndl->int_info2 | info2_reg);
+}
+/**********************************************************************************************************************
+ * End of function _sd_get_info2
+ *********************************************************************************************************************/
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_init.c b/plat/renesas/rz/common/drivers/sd/sd_init.c
new file mode 100644
index 000000000..f5c3ab8ef
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_init.c
@@ -0,0 +1,290 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_init.c
+ * Version      : 1.0
+ * Description  : SD Driver initialize.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"
+#include "sys_sel.h"
+#include "sd.h"
+#include "ut_define.h"
+
+#include <assert.h>
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+int32_t SDSelectPort;
+SDHNDL *SDHandle[NUM_PORT];
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esd_init
+ * Description  : initialize SD Driver work memory started from SDHI register base
+ *              : address specified by argument (base)
+ *              : initialize port specified by argument (cd_port)
+ *              : work memory is allocated quadlet boundary
+ * Arguments    : uintptr_t base : SDHI register base address
+ *              : void *workarea : SD Driver work memory
+ *              : int32_t cd_port : card detect port
+ *              :   SD_CD_SOCKET : card detect by CD pin
+ *              :   SD_CD_DAT3 : card detect by DAT3 pin
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *              : SD_ERR_CPU_IF : CPU-IF function error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_init(uintptr_t base, void *workarea, int32_t cd_port)
+{
+    int32_t  i;
+    int32_t  j;
+    uint16_t info1;
+    uint8_t  *p_ptr;
+    SDHNDL   *p_hndl;
+    int32_t  ret;
+
+
+    /* ==== Initialize work memory  ==== */
+    if((uintptr_t)workarea == 0)
+    {
+        ret = SD_ERR;
+        goto ErrExit;
+    }
+
+    /* ==== Work memory boundary check (quadlet unit) ==== */
+    if((uintptr_t)workarea & 0x3u)
+    {
+        ret = SD_ERR;
+        goto ErrExit;
+    }
+
+    /* ==== Check card detect port ==== */
+    if((cd_port != SD_CD_SOCKET) && (cd_port != SD_CD_DAT3))
+    {
+        ret = SD_ERR;
+        goto ErrExit;
+    }
+
+    /* Card detect port is fixed at CD pin */
+/*    cd_port = SD_CD_SOCKET;*/
+
+    /* ==== Initialize peripheral module ==== */
+    if(esddev_init() != SD_OK)
+    {
+        ret = SD_ERR_CPU_IF;
+        goto ErrExit;
+    }
+
+    /* Disable all interrupts */
+    esddev_loc_cpu();
+
+    p_hndl = (SDHNDL *)workarea;
+
+    for(j = 0;j < NUM_PORT; j++)
+    {
+        SDHandle[j] = p_hndl;
+
+        /* ---- Clear work memory zero value --- */
+        p_ptr = (uint8_t *)p_hndl;
+        for(i= sizeof(SDHNDL); i > 0 ;i--)
+        {
+            *p_ptr++ = 0;
+        }
+
+        /* ---- Set SDHI register address ---- */
+        p_hndl->reg_base = base;
+        p_hndl->cd_port = (uint8_t)cd_port;
+        /* ---- Initialize maximum block count ---- */
+        p_hndl->trans_sectors = 256;
+
+        p_hndl->port = (uint8_t)j;        /* Set select port number */
+
+        p_hndl++;    /* Point to next handle */
+    }
+
+    /* Return to select port0 */
+    SDSelectPort = 0;
+    p_hndl = _sd_get_hndl();
+
+    /* ==== Initialize SDHI ==== */
+    sd_outp(p_hndl,SD_INFO1_MASK,0x031d);
+    sd_outp(p_hndl,SD_INFO2_MASK,0x837f);
+    sd_outp(p_hndl,SDIO_INFO1_MASK,0xc007);
+    sd_outp(p_hndl,SDIO_MODE,0x0000);
+    info1 = sd_inp(p_hndl,SD_INFO1);
+    sd_outp(p_hndl,SD_INFO1,(uint16_t)(info1&~0x0005u));
+    sd_outp(p_hndl,SD_INFO2,0x0000);
+    sd_outp(p_hndl,SDIO_INFO1,0x0000);
+    if(NUM_PORT > 1)
+    {
+        sd_outp(p_hndl,EXT_SDIO,0x0777);
+        sd_outp(p_hndl,EXT_CD_MASK,0x00ff);
+        sd_outp(p_hndl,EXT_CD_DAT3_MASK,0x00ff);
+    }
+    sd_outp(p_hndl,SOFT_RST,0);
+    sd_outp(p_hndl,SOFT_RST,1);
+
+    /* BUS SIZE setting */
+    sd_outp(p_hndl,HOST_MODE,0x00000101);
+
+    /* 0x00a*; If SDCLK is 16.6MHz, set the count value for timeout 503msec */
+    sd_outp(p_hndl,SD_OPTION,0x00ae);
+
+    /* Enable all interrupts */
+    esddev_unl_cpu();
+
+    return SD_OK;
+ErrExit:
+    for(i = 0;i < NUM_PORT;i++)
+    {
+        SDHandle[i] = 0;    /* Relese SD handle */
+    }
+    return ret;
+}
+/**********************************************************************************************************************
+ * End of function esd_init
+ *********************************************************************************************************************/
+
+#if 0
+
+#endif
+
+/**********************************************************************************************************************
+ * Function Name: _sd_init_hndl
+ * Description  : initialize following SD handle members
+ *              : media_type : card type
+ *              : write_protect : write protect
+ *              : resp_status : R1/R1b response status
+ *              : error : error detail information
+ *              : stop : compulsory stop flag
+ *              : prot_sector_size : sector size (protect area)
+ *              : card registers : ocr, cid, csd, dsr, rca, scr, sdstatus and status_data
+ * Arguments    : none.SDHNDL *hndl : SD handle
+ *              : uint32_t mode : driver mode
+ *              : uint32_t voltage : working voltage
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_init_hndl(SDHNDL *hndl, uint32_t mode, uint32_t voltage)
+{
+    int32_t i;
+
+    hndl->media_type = SD_MEDIA_UNKNOWN;
+    hndl->write_protect = 0;
+    hndl->resp_status = STATE_IDEL;
+    hndl->error = SD_OK;
+    hndl->stop = 0;
+    hndl->prot_sector_size = 0;
+    hndl->voltage = voltage;
+    hndl->speed_mode = 0;
+    hndl->int_mode =   (uint8_t)(mode & 0x01u);
+    hndl->trans_mode = (uint8_t)(mode & 0x02u);
+    hndl->sup_card =   (uint8_t)(mode & 0x30u);
+    hndl->sup_speed =  (uint8_t)(mode & 0x40u);
+    hndl->sup_ver =    (uint8_t)(mode & 0x80u);
+
+    /* Initialize card registers */
+    for(i = 0; i < (4/sizeof(uint16_t)); ++i)
+    {
+        hndl->ocr[i] = 0;
+    }
+    for(i = 0; i < (16/sizeof(uint16_t)); ++i)
+    {
+        hndl->cid[i] = 0;
+    }
+    for(i = 0; i < (16/sizeof(uint16_t)); ++i)
+    {
+        hndl->csd[i] = 0;
+    }
+    for(i = 0; i < (2/sizeof(uint16_t)); ++i)
+    {
+        hndl->dsr[i] = 0;
+    }
+    for(i = 0; i < (4/sizeof(uint16_t)); ++i)
+    {
+        hndl->rca[i] = 0;
+    }
+    for(i = 0; i < (8/sizeof(uint16_t)); ++i)
+    {
+        hndl->scr[i] = 0;
+    }
+    /* For expand SD STATUS relevant fields */
+    for(i = 0; i < (14/sizeof(uint16_t)); ++i)
+    {
+        hndl->sdstatus[i] = 0;
+    }
+    for(i = 0; i < (18/sizeof(uint16_t)); ++i)
+    {
+        hndl->status_data[i] = 0;
+    }
+    for(i = 0; i < (4/sizeof(uint16_t)); ++i)
+    {
+        hndl->if_cond[i] = 0;
+    }
+
+    if(hndl->sup_card & SD_MODE_IO)
+    {
+        int32_t j;
+
+        hndl->io_flag = 0;
+        hndl->io_info = 0;
+
+        for(i = 0; i < (4/sizeof(uint16_t)); ++i)
+        {
+            hndl->io_ocr[i] = 0;
+        }
+
+        for(i = 0; i < 6; ++i)
+        {
+            for(j = 0; j < (0x14/sizeof(uint8_t)); ++j)
+            {
+                hndl->io_reg[i][j] = 0;
+            }
+        }
+    }
+
+    if(hndl->sup_ver == SD_MODE_VER2X)
+    {
+        hndl->if_cond[0] = 0;
+        hndl->if_cond[1] = 0x00aa;
+        if(hndl->voltage & 0x00FF8000)
+        {
+            hndl->if_cond[1] |= 0x0100;    /* High volatege : 2.7V-3.6V */
+        }
+        if(hndl->voltage & 0x00000F00)
+        {
+            hndl->if_cond[1] |= 0x0200;    /* Low volatege : 1.65V-1.95V */
+        }
+    }
+
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_init_hndl
+ *********************************************************************************************************************/
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_int.c b/plat/renesas/rz/common/drivers/sd/sd_int.c
new file mode 100644
index 000000000..5920c59a7
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_int.c
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_int.c
+ * Version      : 1.0
+ * Description  : SD_INFO1 and SD_INFO2 interrupt.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"
+#include "sys_sel.h"
+#include "sd.h"
+#include "ut_define.h"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_set_int_mask
+ * Description  : set int_info1_mask and int_info2_mask depend on the mask bits value
+ *              : if mask bit is one, it is enabled
+ *              : if mask bit is zero, it is disabled
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t mask1 : SD_INFO1_MASK1 bits value
+ *              : uint16_t mask2 : SD_INFO1_MASK2 bits value
+ * Return Value : SD_OK : end of succeed
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t    _sd_set_int_mask(SDHNDL *hndl, uint16_t mask1, uint16_t mask2)
+{
+    esddev_loc_cpu();
+    
+    /* ---- Set int_info1_mask and int_info2_mask ---- */
+    hndl->int_info1_mask |= mask1;
+    hndl->int_info2_mask |= mask2;
+
+    /* ---- Set hardware mask ---- */
+    sd_outp(hndl,SD_INFO1_MASK,(uint16_t)~(hndl->int_info1_mask));
+    sd_outp(hndl,SD_INFO2_MASK,(uint16_t)~(hndl->int_info2_mask));
+
+    esddev_unl_cpu();
+
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_set_int_mask
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_clear_int_mask
+ * Description  : clear int_cc_status_mask depend on the mask bits value
+ *              : if mask bit is one, it is disabled
+ *              : if mask bit is zero, it is enabled
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t mask1 : SD_INFO1_MASK1 bits value
+ *              : uint16_t mask2 : SD_INFO1_MASK2 bits value
+ * Return Value : SD_OK : end of succeed
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_clear_int_mask(SDHNDL *hndl, uint16_t mask1, uint16_t mask2)
+{
+    esddev_loc_cpu();
+    
+    /* ---- Clear int_info1_mask and int_info2_mask ---- */
+    hndl->int_info1_mask &= (uint16_t)~mask1;
+    hndl->int_info2_mask &= (uint16_t)~mask2;
+    
+    /* ---- Clear hardware mask ---- */
+    sd_outp(hndl,SD_INFO1_MASK,(uint16_t)~(hndl->int_info1_mask));
+    sd_outp(hndl,SD_INFO2_MASK,(uint16_t)~(hndl->int_info2_mask));
+    
+    esddev_unl_cpu();
+    
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_clear_int_mask
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_clear_info
+ * Description  : clear int_info1 and int_info2 depend on the clear value
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t clear_info1 : int_info1 clear bits value
+ *              : uint16_t clear_info2 : int_info2 clear bits value
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : SD_INFO1 and SD_INFO2 bits are not cleared
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_clear_info(SDHNDL *hndl, uint16_t clear_info1, uint16_t clear_info2)
+{
+    esddev_loc_cpu();
+    
+    /* ---- Clear int_info1 and int_info2 ---- */
+    hndl->int_info1 &= (uint16_t)~clear_info1;
+    hndl->int_info2 &= (uint16_t)~clear_info2;
+
+    esddev_unl_cpu();
+    
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_clear_info
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_get_int
+ * Description  : get SD_INFO1 and SD_INFO2 bits
+ *              : examine enabled elements
+ *              : hearafter, clear SD_INFO1 and SD_INFO2 bits
+ *              : save those bits to int_info1 or int_info2
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_get_int(SDHNDL *hndl)
+{
+    uint16_t info1;
+    uint16_t info2;
+    uint16_t ret = 0;
+
+    /* Get SD_INFO1 and SD_INFO2 bits */
+    info1 = (uint16_t)(sd_inp(hndl,SD_INFO1) & hndl->int_info1_mask);
+    info2 = (uint16_t)(sd_inp(hndl,SD_INFO2) & hndl->int_info2_mask);
+
+    /* Clear SD_INFO1 and SD_INFO2 bits */
+    sd_outp(hndl,SD_INFO1,(uint16_t)~info1);
+    sd_outp(hndl,SD_INFO2,(uint16_t)~info2);
+        
+    /* Save enabled elements */
+    /* @080218 SDIO support and interrupt delay countermeasures */
+    hndl->int_info1 |= info1;
+    hndl->int_info2 |= info2;
+
+    if(hndl->port != 0)
+    {
+        ret = (uint16_t)_sd_get_ext_cd_int(hndl);
+    }
+    if(info1 || info2 || ret)
+    {
+        return SD_OK;    /* Any interrupt occured */
+    }
+    
+    return SD_ERR;    /* No interrupt occured */
+}
+/**********************************************************************************************************************
+ * End of function _sd_get_int
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esd_check_int
+ * Description  : check SD_INFO1 and SD_INFO2 interrupt elements
+ *              : if any interrupt is detected, return SD_OK
+ *              : if no interrupt is detected, return SD_ERR
+ * Arguments    : none
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_check_int(void)
+
+{
+    SDHNDL *p_hndl;
+    
+    p_hndl = _sd_get_hndl();
+    if(p_hndl == 0)
+    {
+        return SD_ERR;    /* Not initialized */
+    }
+    
+    if(p_hndl->int_mode)
+    {
+        /* ---- Hardware interrupt mode ---- */
+        if(p_hndl->int_info1 || p_hndl->int_info2)
+        {
+            return SD_OK;
+        }
+        else
+        {
+            return SD_ERR;
+        }
+    }
+
+    /* ---- Polling mode ---- */
+    return _sd_get_int(p_hndl);
+}
+/**********************************************************************************************************************
+ * End of function esd_check_int
+ *********************************************************************************************************************/
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_main.c b/plat/renesas/rz/common/drivers/sd/sd_main.c
new file mode 100644
index 000000000..5df34e29f
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_main.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_main.c
+ * Version      : 1.0
+ * Description  : SD Driver main.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 07.22.2022 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <assert.h>
+#include <esdif.h>
+#include <boot_esd_if.h>
+#include <ut_define.h>
+#include <sd.h>
+#include <boot_esd_if.h>
+#include <boot_common.h>
+#include <cpg_iodefine.h>
+
+uint64_t gl_uwWorkBuffer[ ESD_SIZE_OF_INIT / sizeof(uint64_t) ];         /* WorkSpace for eSD driver Library */
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+static void esd_init_param( stESD_BOOT_OUTPUT* pstOutput );
+
+/**********************************************************************************************************************
+ * Function Name: esd_main
+ * Description  : Initializes and mounts the working memory of the SD driver.
+ * Arguments    : void
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_main(void)
+{
+	int32_t subret;
+	uint16_t ubcardtype;
+	uint8_t  ubcardspeed;
+	uint8_t  ubcardcapacity;
+	stESD_BOOT_OUTPUT stesdboot_output;
+
+	subret=0;
+	esd_init_param( (stESD_BOOT_OUTPUT* )&stesdboot_output );
+
+	subret=0;
+	subret = esd_init(_SDHI0_BASE_,gl_uwWorkBuffer,SD_CD_SOCKET);
+	if (SD_OK != subret) {
+		NOTICE("BL2: Failed to esd_init.\n");
+		return SD_ERR;
+    }
+
+	subret=0;
+	subret = esd_set_buffer((void *)RAM_LSBLOCK_ADDR,   /* Specify format buffer that has 512byte */
+									SD_SECTOR_SIZE);    /* format buffer size is specify */
+	if (SD_OK != subret) {
+		NOTICE("BL2: Failed to esd_set_buffer.\n");
+		return SD_ERR;
+    }
+
+	subret=0;
+	subret = esd_check_media();
+	if (SD_OK != subret) {
+		NOTICE("BL2: Failed to esd_check_media.\n");
+		return SD_ERR;
+	}
+
+	subret=0;
+	subret = esd_mount((SD_MODE_POLL |  SD_MODE_SW  |  SD_MODE_DS | SD_MODE_VER2X), SD_VOLT_3_3);
+	if (SD_OK != subret) {
+		NOTICE("BL2: Failed to esd_mount.\n");
+		return SD_ERR;
+	}
+
+	subret=0;
+	ubcardtype=0;
+	ubcardspeed=0;
+	ubcardcapacity=0;
+	subret = esd_get_type((uint16_t *)&ubcardtype,
+							(uint8_t *) &ubcardspeed,
+							(uint8_t *) &ubcardcapacity);
+	if( SD_OK != subret ) {
+		NOTICE("BL2: Failed to esd_get_type.\n");
+		return SD_ERR;
+	}
+	else if( ( ubcardtype & SD_MEDIA_SD ) == SD_MEDIA_SD ) {
+            /* none */
+    }
+    else if( ( ubcardtype & SD_MEDIA_EMBEDDED ) == SD_MEDIA_EMBEDDED ) {
+            /* No operation */
+    }
+    else {
+        /* Error break with invalid card type */
+		NOTICE("BL2: Failed to esd_get_type.\n");
+		return SD_ERR;
+    }
+
+	subret=0;
+    subret = esd_get_partition_id(
+		 (int32_t *)&stesdboot_output.ipartition_number );
+	if (SD_OK != subret) {
+		NOTICE("BL2: Failed to esd_get_partition_id.\n");
+		return SD_ERR;
+	}
+
+	subret=0;
+    subret = esd_read_sect(( uint8_t *)0x44000000, 1, 1);
+	if (SD_OK != subret) {
+		NOTICE("BL2: Failed to esd_read_sect.\n");
+		return SD_ERR;
+	}
+
+    return SD_OK;
+}
+
+static void esd_init_param( stESD_BOOT_OUTPUT* pstOutput )
+{
+    pstOutput->ipartition_number      = -1;
+    pstOutput->ierror_code            = -1;
+    pstOutput->iloadersize_blkno      = -1;
+    pstOutput->iloadersize_blknum     = -1;
+    pstOutput->iloaderprog_blkno      = -1;
+    pstOutput->iloaderprog_blknum     = -1;
+}
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_mount.c b/plat/renesas/rz/common/drivers/sd/sd_mount.c
new file mode 100644
index 000000000..16ae1f773
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_mount.c
@@ -0,0 +1,977 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_mount.c
+ * Version      : 1.0
+ * Description  : Card mount.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"
+#include "sys_sel.h"
+#include "sd.h"
+#include "ut_define.h"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+SD_DRV_ZIDATA_SEC static uint16_t stat_buff[64/sizeof(uint16_t)];
+
+/**********************************************************************************************************************
+ * Function Name: esd_mount
+ * Description  : mount SD memory card user area
+ *              : can be access user area after this function is finished
+ *              : without errors
+ *              : turn on power
+ *              : 
+ *              : following is available SD Driver mode
+ *              : SD_MODE_POLL: software polling
+ *              : SD_MODE_HWINT: hardware interrupt
+ *              : SD_MODE_SW: software data transfer (SD_BUF)
+ *              : SD_MODE_DMA: DMA data transfer (SD_BUF)
+ *              : SD_MODE_MEM: only memory cards
+ *              : SD_MODE_IO: memory and io cards
+ *              : SD_MODE_COMBO: memory ,io and combo cards
+ *              : SD_MODE_DS: only default speed
+ *              : SD_MODE_HS: default and high speed
+ *              : SD_MODE_VER1X: ver1.1 host
+ *              : SD_MODE_VER2X: ver2.x host
+ * Arguments    : uint32_t mode : SD Driver operation mode.
+ *              : uint32_t voltage : operation voltage.
+ * Return Value : hndl->error : SD handle error value
+ *              : SD_OK : end of succeed
+ *              : other: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_mount(uint32_t mode, uint32_t voltage)
+{
+    SDHNDL     *p_hndl;
+    uint8_t  spec;
+    uint16_t info1_back;
+
+    p_hndl = _sd_get_hndl();
+    if(p_hndl == 0)
+    {
+        return SD_ERR;    /* Not initialized */
+    }
+
+    /* ==== Check work buffer is allocated ==== */
+    if(p_hndl->rw_buff == 0)
+    {
+        return SD_ERR;    /* Not allocated yet */
+    }
+    
+    /* ==== Initialize parameter ==== */
+    _sd_init_hndl(p_hndl, mode, voltage);
+    p_hndl->error = SD_OK;
+    
+    /* ==== Is card inserted? ==== */
+    if(_sd_check_media(p_hndl) != SD_OK)
+    {
+        _sd_set_err(p_hndl,SD_ERR_NO_CARD);
+        return p_hndl->error;        /* Not inserted */
+    }
+    
+    /* ==== Power on sequence ==== */
+    /* ---- Turn on voltage ---- */
+    if(esddev_power_on() != SD_OK)
+    {
+        _sd_set_err(p_hndl,SD_ERR_CPU_IF);
+        goto ERR_EXIT;
+    }
+
+    /* ---- Set single port ---- */
+    _sd_set_port(p_hndl,SD_PORT_SERIAL);
+
+    /* ---- Supply clock (card-identification ratio) ---- */
+    if(_sd_set_clock(p_hndl,SD_CLK_400kHz,SD_CLOCK_ENABLE) != SD_OK)
+    {
+        return p_hndl->error;        /* Not inserted */
+    }
+
+    esddev_int_wait(2);    /* Add wait function  */
+
+    esddev_loc_cpu();
+
+    info1_back = sd_inp(p_hndl,SD_INFO1);
+    info1_back &= 0xfff8;
+    sd_outp(p_hndl,SD_INFO1,info1_back);
+    sd_outp(p_hndl,SD_INFO2,0);
+
+    esddev_unl_cpu();
+
+    /* ==== Initialize card and distinguish card type ==== */
+    if(_sd_card_init(p_hndl) != SD_OK)
+    {
+        goto ERR_EXIT;    /* Failed card initialize */
+    }
+
+    if(p_hndl->media_type & SD_MEDIA_MEM)     /* With memory part */
+    {
+        /* ==== Check card registers ==== */
+        /* ---- Check CSD register ---- */
+        if(_sd_check_csd(p_hndl) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+        
+        /* ---- No check other registers (to be create) ---- */
+        
+        /* Get user area size */
+        if(_sd_get_size(p_hndl,SD_USER_AREA) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+            
+        /* Check write protect */
+        p_hndl->write_protect |= (uint8_t)_sd_iswp(p_hndl);
+    }
+    
+    if(p_hndl->media_type & SD_MEDIA_MEM)     /* With memory part */
+    {
+        if(_sd_mem_mount(p_hndl) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+    }
+
+    /* If SD memory card, get SCR register */
+    if(p_hndl->media_type & SD_MEDIA_SD)
+    {
+        if(_sd_card_get_scr(p_hndl) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+
+        spec = (uint8_t)((p_hndl->scr[0] & 0x0F00u) >> 8u);
+        if(spec)    /* ---- More than phys spec ver1.10 ---- */
+        {
+            p_hndl->sd_spec = spec;
+            if(p_hndl->sup_speed == SD_MODE_HS)
+            {
+                /* Set memory part speed */
+                if(_sd_set_mem_speed(p_hndl) != SD_OK)
+                {
+                    goto ERR_EXIT;
+                }
+            }
+            _sd_calc_erase_sector(p_hndl);
+
+        }
+
+        else        /* ---- Phys spec ver1.00 or ver1.01 ---- */
+        {
+            p_hndl->sd_spec = SD_SPEC_10;
+        }
+    }
+
+    /* ---- Set mount flag ---- */
+    p_hndl->mount = 1;
+
+    return p_hndl->error;
+
+ERR_EXIT:
+    /* ---- Halt clock ---- */
+    _sd_set_clock(p_hndl,0,SD_CLOCK_DISABLE);
+    return p_hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function esd_mount
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_card_init
+ * Description  : initialize card from idle state to stand-by
+ *              : distinguish card type (SD, MMC, IO or COMBO)
+ *              : get CID, RCA, CSD from the card.
+ * Arguments    : SDHNDL *hndl : SD handle.
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_card_init(SDHNDL *hndl)
+{
+    int32_t ret;
+    int32_t i;
+
+    /* ==== Transfer idle state (issue CMD0) ==== */
+    for(i=0; i < 3; i++)
+    {
+        ret = _sd_send_cmd(hndl,CMD0);
+        if(ret == SD_OK)
+        {
+            break;
+        }
+    }
+
+    if(ret != SD_OK)
+    {
+        return SD_ERR;    /* Error for CMD0 */
+    }
+    /* Clear error by reissuing CMD0 */
+    hndl->error = SD_OK;
+
+    hndl->media_type |= SD_MEDIA_SD;
+
+    /* Refer "2.4.7.2 Booting from eSD correspondence" */
+    /* When CMD0 is executed, the physical partition returns to #0 which is UserArea */
+    hndl->partition_id = 0;
+
+    if(hndl->sup_ver == SD_MODE_VER2X)
+    {
+        ret = _sd_card_send_cmd_arg(hndl,CMD8,SD_RESP_R7,hndl->if_cond[0],
+            hndl->if_cond[1]);
+        if(ret == SD_OK)
+        {
+            /* Check R7 response */
+            if(hndl->if_cond[0] & 0xf000)
+            {
+                hndl->error = SD_ERR_IFCOND_VER;
+                return SD_ERR;
+            }
+            if((hndl->if_cond[1] & 0x00ff) != 0x00aa)
+            {
+                hndl->error = SD_ERR_IFCOND_ECHO;
+                return SD_ERR;
+            }
+        }
+        else
+        {
+            /* ==== Clear illegal command error for CMD8 ==== */
+            for(i=0; i < 3; i++)
+            {
+                ret = _sd_send_cmd(hndl,CMD0);
+                if(ret == SD_OK)
+                {
+                    break;
+                }
+            }
+
+            hndl->error = SD_OK;
+        }
+    }
+
+    /* Set OCR (issue ACMD41) */
+    ret = _sd_card_send_ocr(hndl,(int32_t)hndl->media_type);
+
+    if(hndl->error == SD_ERR_CARD_LOCK)
+    {
+        return SD_ERR;
+    }
+
+    /* Clear error due to card distinction */
+    hndl->error = SD_OK;
+    
+    if(ret != SD_OK)
+    {
+        /* Softreset for error clear (issue CMD0) */
+        for(i=0; i < 3; i++)
+        {
+            ret = _sd_send_cmd(hndl,CMD0);
+            if( ret == SD_OK)
+            {
+                break;
+            }
+        }
+        if(ret != SD_OK)
+        {
+            return SD_ERR;    /* Error for CMD0 */
+        }
+        /* Clear error by reissuing CMD0 */
+        hndl->error = SD_OK;
+        /* ---- Get OCR (issue CMD1) ---- */
+        if((ret = _sd_card_send_ocr(hndl,SD_MEDIA_MMC)) == SD_OK)
+        {
+            /* MMC */
+            hndl->media_type = SD_MEDIA_MMC;
+            hndl->error = SD_OK;
+        }
+        else
+        {
+            /* Unknown card */
+            hndl->media_type = SD_MEDIA_UNKNOWN;
+            _sd_set_err(hndl,SD_ERR_CARD_TYPE);
+            return SD_ERR;
+        }
+    }
+
+    /* ---- Get CID (issue CMD2) ---- */
+    if(_sd_card_send_cmd(hndl,CMD2,SD_RESP_R2_CID) != SD_OK)
+    {
+        return SD_ERR;
+    }
+    
+/* GET_RCA: */
+    /* ---- Get RCA (issue CMD3) ---- */
+    if(hndl->media_type & SD_MEDIA_COMBO)       /* IO or SD */
+    {
+        for(i=0; i < 3; i++)
+        {
+            if(_sd_card_send_cmd(hndl,CMD3,SD_RESP_R6) != SD_OK)
+            {
+                return SD_ERR;
+            }
+            if(hndl->rca[0] != 0x00)
+            {
+                if(hndl->media_type & SD_MEDIA_IO)
+                {
+                    hndl->io_flag |= SD_IO_POWER_INIT;
+                }
+                break;
+            }
+        }
+        /* Illegal RCA */
+        if(i == 3)
+        {
+            _sd_set_err(hndl,SD_ERR_CARD_CC);
+            return SD_ERR;
+        }
+    }
+    else
+    {
+        hndl->rca[0] = (uint16_t)(hndl->port + 1);
+        if(_sd_card_send_cmd_arg(hndl,CMD3,SD_RESP_R1,hndl->rca[0],0x0000) != SD_OK)
+        {
+            return SD_ERR;
+        }
+    }
+
+    /* ==== Stand-by state  ==== */
+    
+    if(hndl->media_type == SD_MEDIA_IO)
+    {
+        return SD_OK;
+    }
+
+    /* ---- Get CSD (issue CMD9) ---- */
+    if(_sd_card_send_cmd_arg(hndl,CMD9,SD_RESP_R2_CSD,hndl->rca[0],0x0000) != SD_OK)
+    {
+        return SD_ERR;
+    }
+
+    hndl->dsr[0] = 0x0000;
+
+    if(hndl->media_type & SD_MEDIA_MEM)
+    {
+        /* Is DSR implimented? */
+        if(hndl->csd[3] & 0x0010u)
+        {    /* Implimented */
+            /* Set DSR (issue CMD4) */
+            hndl->dsr[0] = 0x0404;
+        }
+    }
+    
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_card_init
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_mem_mount
+ * Description  : mount memory part from stand-by to transfer state.
+ * Arguments    : SDHNDL *hndl : SD handle.
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error.
+ * Remark       : Added processing to select the physical partition #1
+ *              : If you can select #1, issue CMD45.
+ *              : After that, the currently selected the physical partition is obtained 
+ *              : and saved in the internal variable hndl->partition_id.
+ *              : *** About reason not to issue CMD45 unconditionally
+ *              : *** See esd_select_partition() function column
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_mem_mount(SDHNDL *hndl)
+{
+    /* Case of combo, already supplied data transfer clock */
+    if((hndl->media_type & SD_MEDIA_IO) == 0)
+    {
+        /* Def ESD_DRIVER_CLOCK_SWITCH *** Must be enabled */
+        /* ---- Supply clock (data-transfer ratio) ---- */
+        if(_sd_set_clock(hndl,(int)hndl->csd_tran_speed,SD_CLOCK_ENABLE) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+    }
+    
+    /* ==== Data-transfer mode ==== */
+    if(_sd_card_send_cmd_arg(hndl,CMD7,SD_RESP_R1b,hndl->rca[0],0x0000) != SD_OK)
+    {
+        goto ERR_EXIT;
+    }
+
+    /* select the physical partition #1 */
+    if(_sd_card_select_partition(hndl, 1) == SD_OK)
+    {
+        /* Get changed partition ID from device */
+        int32_t tmp_id;
+        if(_esd_get_partition_id(hndl, &tmp_id) == SD_OK)
+        {
+            /* Save ID obtained from device */
+            hndl->partition_id = tmp_id;
+        }
+    }
+    else
+    {
+        /* It is NG in the internal function, but it is treated as SD_OK considering the subsequent processing */
+        hndl->error = SD_OK;
+        /* Don't save ID */
+    }
+    
+    /* ---- Set block length (issue CMD16) ---- */
+    if(_sd_card_send_cmd_arg(hndl,CMD16,SD_RESP_R1,0x0000,0x0200) != SD_OK)
+    {
+        goto ERR_EXIT;
+    }
+
+    /* If 4bits transfer supported (SD memory card mandatory), change bus width 4bits */
+    if(hndl->media_type & SD_MEDIA_SD)
+    {
+        _sd_set_port(hndl,SD_PORT_PARALLEL);
+    }
+
+    /* Clear pull-up DAT3 */
+    if(hndl->media_type & SD_MEDIA_SD)
+    {
+        if(_sd_send_acmd(hndl,ACMD42,0,0) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+        /* Check R1 resp */
+        if(_sd_get_resp(hndl,SD_RESP_R1) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+    }
+
+    /* If SD memory card, get SD Status */
+    if(hndl->media_type & SD_MEDIA_SD)
+    {
+        if(_sd_card_get_status(hndl) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+        /* Get protect area size */
+        if(_sd_get_size(hndl,SD_PROT_AREA) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+    }
+
+    return SD_OK;
+
+ERR_EXIT:
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_mem_mount
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_set_mem_speed
+ * Description  : query high speed supported
+ *              : transfer card high speed mode.
+ * Arguments    : SDHNDL *hndl : SD handle.
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error.
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_set_mem_speed(SDHNDL *hndl)
+{
+    /* Query func */
+    if(_sd_card_switch_func(hndl,0x00FF,0xFF00) != SD_OK)
+    {
+        goto ERR_EXIT;
+    }
+    if(hndl->speed_mode & SD_SUP_SPEED)     /* High speed supported */
+    {
+
+        /* Make transfer card high speed mode */
+        if(_sd_card_switch_func(hndl,0x80FF,0xFF01) != SD_OK)
+        {
+            goto ERR_EXIT;
+        }
+
+        /* Case of combo card, set clock frequency high speed after transfering  io part high speed */
+        if(hndl->media_type == SD_MEDIA_SD)
+        {
+            hndl->csd_tran_speed = SD_CLK_50MHz;
+            hndl->speed_mode |= SD_CUR_SPEED;
+        }
+
+        hndl->csd[2] &= 0x00ff;
+        hndl->csd[2] |= 0x5a00;
+
+    }
+
+    return SD_OK;
+
+ERR_EXIT:
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_set_mem_speed
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_card_switch_func
+ * Description  : issue SWITCH FUNC command
+ *              : query card is high speed supported
+ *              : make transfer card high speed mode.
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint16_t h_arg : command argument high [31:16]
+ *              : uint16_t l_arg : command argument low [15:0]
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_card_switch_func(SDHNDL *hndl, uint16_t h_arg, uint16_t l_arg)
+{
+    int32_t i;
+    uint8_t *p_rw_buff = (uint8_t *)stat_buff;
+    
+    if(_sd_read_byte(hndl,CMD6,h_arg,l_arg,p_rw_buff,STATUS_DATA_BYTE) != SD_OK)
+    {
+        return SD_ERR;
+    }
+
+    /* ---- Save STATUS DATA ---- */
+    for(i=0; i<9 ;i++)
+    {
+        hndl->status_data[i] = (stat_buff[i] << 8) | (stat_buff[i] >> 8);
+    }
+    
+    if(!(h_arg & 0x8000))       /* Case of query */
+    {
+        /* ---- Save high speed support ---- */
+        if(hndl->status_data[6] & 0x0002u)
+        {
+            hndl->speed_mode |= SD_SUP_SPEED;
+        }
+        else
+        {
+            hndl->speed_mode &= (uint8_t)~SD_SUP_SPEED;
+        }
+    }
+
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_card_switch_func
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_card_get_status
+ * Description  : get SD Status (issue ACMD13).
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_card_get_status(SDHNDL *hndl)
+{
+    int32_t ret;
+    int32_t i;
+    uint8_t *p_rw_buff = (uint8_t *)stat_buff;
+    
+    /* ---- Get SD Status (issue ACMD13) ---- */
+    if(_sd_read_byte(hndl,ACMD13,0,0,p_rw_buff,SD_STATUS_BYTE) != SD_OK)
+    {
+        return SD_ERR;
+    }
+    
+    /* ---- Distinguish SD ROM card ---- */
+    /* Modifies for Little endian */
+    if((p_rw_buff[2] & 0xffu) == 0x00)    /* [495:488] = 0x00 */
+    {
+        ret = SD_OK;
+        /* Correspond to SD ROM Card judgment position error */
+        if((p_rw_buff[3] & 0xffu) == 0x01)
+        {
+            hndl->write_protect |= SD_WP_ROM;
+        }
+    }
+    else
+    {
+        ret = SD_ERR;
+        _sd_set_err(hndl,SD_ERR_CARD_ERROR);
+    }
+
+    /* @060526 for SD phy ver2.0 */
+    hndl->speed_class = p_rw_buff[8];
+    hndl->perform_move = p_rw_buff[9];
+
+    
+    /* ---- Save SD STATUS ---- */
+    /* @050916 for expand SD STATUS relevant fields */
+    for(i = 0;i < (14/sizeof(uint16_t)) ;i++)
+    {
+        /* Modifies for Little endian */
+        hndl->sdstatus[i] = (stat_buff[i] << 8) | (stat_buff[i] >> 8); 
+
+    }
+    
+    return ret;
+}
+/**********************************************************************************************************************
+ * End of function _sd_card_get_status
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_card_get_scr
+ * Description  : get SCR register (issue ACMD51).
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_OK : end of succeed
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_card_get_scr(SDHNDL *hndl)
+{
+    uint8_t *p_rw_buff = (uint8_t *)stat_buff;
+
+    /* ---- Get SCR register (issue ACMD51) ---- */
+    if(_sd_read_byte(hndl,ACMD51,0,0,p_rw_buff,SD_SCR_REGISTER_BYTE) != SD_OK)
+    {
+        return SD_ERR;
+    }
+
+    /* ---- Save SCR register ---- */
+    /* Modifies for Little endian */
+    hndl->scr[0] = (stat_buff[0] << 8) | (stat_buff[0] >> 8);
+    hndl->scr[1] = (stat_buff[1] << 8) | (stat_buff[1] >> 8);
+    hndl->scr[2] = (stat_buff[2] << 8) | (stat_buff[2] >> 8);
+    hndl->scr[3] = (stat_buff[3] << 8) | (stat_buff[3] >> 8);
+
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_card_get_scr
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_read_byte
+ * Description  : read byte data from card
+ *              : issue byte data read command and read data from SD_BUF
+ *              : using following commands
+ *              : SD STATUS(ACMD13),SCR(ACMD51),NUM_WRITE_BLOCK(ACMD22),
+ *              : SWITCH FUNC(CMD6).
+ * Arguments    : SDHNDL *hndl :      SD handle
+ *              : uint16_t cmd :      command code
+ *              : uint16_t h_arg :    command argument high [31:16]
+ *              : uint16_t l_arg :    command argument low [15:0]
+ *              : uint8_t *readbuff : read data buffer
+ *              : uint16_t byte :     the number of read bytes
+ * Return Value : SD_OK : end of succeed.
+ * Remark       : transfer type is PIO
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_read_byte(SDHNDL *hndl, uint16_t cmd, uint16_t h_arg,
+    uint16_t l_arg, uint8_t *readbuff, uint16_t byte)
+{
+    /* ---- Disable SD_SECCNT ---- */
+    sd_outp(hndl,SD_STOP,0x0000);
+
+    /* ---- Set transfer bytes ---- */
+    sd_outp(hndl,SD_SIZE,byte);
+
+    /* ---- Issue command ---- */
+    if(cmd & 0x0040u)       /* ACMD13, ACMD22 and ACMD51 */
+    {
+        if(_sd_send_acmd(hndl,cmd,h_arg,l_arg) != SD_OK)
+        {
+            /* For SD_ERR_END_BIT and SD_ERR_CRC, processing is continued because data is stored in FIFO */
+            if((hndl->error == SD_ERR_END_BIT) || (hndl->error == SD_ERR_CRC))
+            {
+                ; /* DO NOTHING */
+            }
+            else
+            {
+                goto ErrExit;
+            }
+        }
+    }
+    else                /* CMD6 and CMD30 */ /* CMD45 */
+    {
+        _sd_set_arg(hndl,h_arg,l_arg);
+        if(_sd_send_cmd(hndl,cmd) != SD_OK)
+        {
+            /* CMD45 non-compatible device countermeasures.To error handling*/
+            goto ErrExit;
+        }
+    }
+    /* ---- Check R1 response ---- */
+    if(_sd_get_resp(hndl,SD_RESP_R1) != SD_OK)
+    {
+        goto ErrExit;
+    }
+
+    /* Enable All end, BRE and errors */
+    _sd_set_int_mask(hndl,SD_INFO1_MASK_DATA_TRNS,SD_INFO2_MASK_BRE);
+
+    /* ---- Wait BRE interrupt ---- */
+    if(esddev_int_wait(SD_TIMEOUT_MULTIPLE) != SD_OK)
+    {
+        _sd_set_err(hndl,SD_ERR_HOST_TOE);
+        goto ErrExit;
+    }    
+
+    /* ---- Check errors ---- */
+    if(hndl->int_info2&SD_INFO2_MASK_ERR)
+    {
+        _sd_check_info2_err(hndl);
+        goto ErrExit;
+    }
+
+    _sd_clear_info(hndl,0x0000,SD_INFO2_MASK_RE);    /* clear BRE bit */
+
+    /* Transfer data */
+    if(esddev_read_data(readbuff,(uintptr_t)(hndl->reg_base+SD_BUF0), (uint32_t)byte) != SD_OK)
+    {
+        _sd_set_err(hndl,SD_ERR_CPU_IF);
+        goto ErrExit;
+    }
+
+    /* Wait All end interrupt */
+    if(esddev_int_wait(SD_TIMEOUT_RESP) != SD_OK)
+    {
+        _sd_set_err(hndl,SD_ERR_HOST_TOE);
+        goto ErrExit;
+    }
+
+    /* ---- Check errors ---- */
+    if(hndl->int_info2&SD_INFO2_MASK_ERR)
+    {
+        _sd_check_info2_err(hndl);
+        goto ErrExit;
+    }
+
+    _sd_clear_info(hndl,SD_INFO1_MASK_DATA_TRNS,SD_INFO2_MASK_ERR);    /* clear All end bit */
+
+    /* Disable all interrupts */
+    _sd_clear_int_mask(hndl,SD_INFO1_MASK_DATA_TRNS,SD_INFO2_MASK_BRE);
+
+    return SD_OK;
+
+ErrExit:
+    sd_outp(hndl,SD_STOP,0x0001);    /* stop data transfer */
+
+    _sd_clear_info(hndl,SD_INFO1_MASK_DATA_TRNS,SD_INFO2_MASK_ERR);    /* clear All end bit */
+
+    /* Disable all interrupts */
+    _sd_clear_int_mask(hndl,SD_INFO1_MASK_DATA_TRNS,SD_INFO2_MASK_BRE);
+
+    {
+        uint16_t info1;
+        /* Countermeasures when the access end is 1 */
+        info1 = (uint16_t)sd_inp(hndl,SD_INFO1);
+        info1 &= 0xFFFB;
+        sd_outp(hndl,SD_INFO1,(uint16_t)info1);
+    }
+    
+    return SD_ERR;
+}
+/**********************************************************************************************************************
+ * End of function _sd_read_byte
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_calc_erase_sector
+ * Description  : This function calculate erase sector for SD Phy Ver2.0..
+ * Arguments    : SDHNDL *hndl :      SD handle
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : transfer type is PIO
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_calc_erase_sector(SDHNDL *hndl)
+{
+    uint16_t au;
+    uint16_t erase_size;
+    
+    if((hndl->scr[0] & 0x0f00) == 0x0200)
+    {
+        /* AU is not defined,set to fixed value */
+        hndl->erase_sect = SD_ERASE_SECTOR;
+
+        /* Get AU size */
+        au = hndl->sdstatus[5] >> 12;
+
+        if((au > 0) && (au < 0x0a))
+        {
+            /* Get AU_SIZE(sectors) */
+            hndl->erase_sect = ((8*1024)/512) << au;
+
+            /* Get ERASE_SIZE */ 
+            erase_size = (hndl->sdstatus[5] << 8) | (hndl->sdstatus[6] >> 8);
+            if(erase_size != 0)
+            {
+                hndl->erase_sect *= erase_size;
+            }
+        }
+        
+    }
+    else
+    {
+        ; /* If card is not Ver2.0,it use ERASE_BLK_LEN in CSD */
+    }
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_calc_erase_sector
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_card_query_partitions
+ * Description  : Issue CMD45 and get QUERY_PARTITIONS information
+ *              : If you can get it, it will be saved in the area of rw_buff.
+ * Arguments    : SDHNDL *hndl             : SD handle
+ *              : int32_t sub              : Sub Command code (0xA1 can be set)
+ *              : uint8_t *rw_buff         : 512byte area
+ * Return Value : SD_OK : end of succeed
+ * Call functions : _sd_read_byte, _sd_card_send_cmd_arg
+ * Note         : rw_buff needs 512Byte area
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC static int32_t _sd_card_query_partitions(SDHNDL *hndl, int32_t sub, uint8_t *rw_buff)
+{
+    /* ---- Get QUERY PARTITIONS (issue CMD45) ---- */
+    if(_sd_read_byte(hndl,CMD45,(uint16_t)(sub<<8),0,rw_buff,SD_QUERY_PARTITION_LIST_BYTE) == SD_OK)
+    {
+        /* If CMD45(eSD) is supported */
+        _sd_card_send_cmd_arg(hndl,CMD13,SD_RESP_R1,hndl->rca[0],0x0000);
+        /* returns the value of CMD13 */
+    }
+    else
+    {
+        /* CMD45(eSD) isn't supported */
+        /* Since next command responds with an error, issue CMD13 to clear the error */
+        int32_t tmp = hndl->error;
+        _sd_card_send_cmd_arg(hndl,CMD13,SD_RESP_R1,hndl->rca[0],0x0000);
+        hndl->error = tmp;
+        /* I want to return the error value at the time of _sd_read_byte() execution,
+         * so temporarily evacuate so that CMD13 is not overwritten */
+    }
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_card_query_partitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_card_select_partition
+ * Description  : SELECT PARTITIONS information [issue CMD43].
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : int32_t id   : Partition ID
+ * Return Value : SD_OK               : SELECT_PARTITION success
+ *              : SD_ERR_RES_TOE      : SELECT_PARTITION not supported
+ *              : SD_ERR_OUT_OF_RANGE : SELECT_PARTITION supported but the specified partition does not exist
+ * Call functions : _sd_card_send_cmd_arg, 
+ * Remark       : Summary of behavior for #SELECT_PARTITION(CMD43)
+ *              : If eSDv2.10(Made by SanDisk eSD) is supported 
+ *              :  - Corresponding device is forcibly terminated regardless of partition
+ *              :  - If it can be changed to the specified partition, next command(CMD13) ends with SD_OK
+ *              :  - Next command(CMD13) returns an OUT_OF_RANGE error if the specified partition does not exist
+ *              : 
+ *              : If eSDv2.10(Made by Tosiba eSD/marketing SDSC/SDHC etc)isn't supported
+ *              :  - If device is not supported, CMD45 ends with NO_RESPONSE
+ *              :  - Since next command responds with an error, issue CMD13 to clear the error
+ *              :  - I want to return the error value at the time of CMD43 execution,
+ *              :    so temporarily evacuate so that CMD13 is not overwritten
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_card_select_partition(SDHNDL *hndl, int32_t id)
+{
+    /* ==== SELECT PARTITIONS(Physical partition #id) ==== */
+    if(_sd_card_send_cmd_arg(hndl,CMD43,SD_RESP_R1b,(uint16_t)(id<<8),0x0000) == SD_OK)
+    {
+        /* If eSDv2.10(Made by SanDisk eSD) is supported */
+        _sd_card_send_cmd_arg(hndl,CMD13,SD_RESP_R1,hndl->rca[0],0x0000);
+        /* Returns the value of CMD13 */
+    }
+    else
+    {
+        /* If eSDv2.10(Made by Toshiba eSD/marketing SDSC/SDHC etc) isn't supported */
+        /* Since next command responds with an error, issue CMD13 to clear the error */
+        int32_t tmp = hndl->error;
+        _sd_card_send_cmd_arg(hndl,CMD13,SD_RESP_R1,hndl->rca[0],0x0000);
+        hndl->error = tmp;
+        /* I want to return the error value at the time of CMD43 execution,
+         * so temporarily evacuate so that CMD13 is not overwritten */
+    }
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_card_select_partition
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _esd_get_partition_id
+ * Description  : Issue CMD45 to device.
+ *              : If failed.
+ *              : Terminates with an error and sets nothing to the argument ID.
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : int32_t *id  : Partition ID
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR : end of error
+ * Call functions : _sd_get_hndl, _sd_set_clock, _sd_card_query_partitions
+ * Remark       : If CMD45 is issued to v2.10 non-compatible device ,
+ *              : the subsequent SINGLE/MULTI_READ will result in an error(SD_ERR_ILL_READ).
+ *              : Therefore, it does not issue CMD45 to non-compliant devices.
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _esd_get_partition_id(SDHNDL *hndl, int32_t *id)
+{
+
+    /* Issue the QUERY_PARTITION(CMD45) command  */
+    if(_sd_card_query_partitions(hndl, 0xA1, hndl->rw_buff) == SD_OK)
+    {
+        /* Stores the currently selected the physical partition number at the 511 byte location */
+        *id = hndl->rw_buff[511];
+    }
+
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _esd_get_partition_id
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esd_get_partition_id
+ * Description  : Get the currently selected partitionID from internal variables.
+ * Arguments    : int32_t *id       : Partition ID
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR : not initialized
+ * Call functions : _sd_get_hndl
+ * Remark       : Get directly from device when partition is selected
+ *              : Therefore,it does not issue CMD45
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_get_partition_id(int32_t *id)
+{
+    SDHNDL    *p_hndl;
+
+    p_hndl = _sd_get_hndl();
+    if(p_hndl == 0)
+    {
+        return SD_ERR;    /* Not initialized */
+    }
+    if(id != 0)
+    {
+        *id = p_hndl->partition_id;
+    }
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function esd_get_partition_id
+ *********************************************************************************************************************/
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_read.c b/plat/renesas/rz/common/drivers/sd/sd_read.c
new file mode 100644
index 000000000..49213a104
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_read.c
@@ -0,0 +1,596 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_read.c
+ * Version      : 1.0
+ * Description  : Card read.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"
+#include "sys_sel.h"
+#include "sd.h"
+#include "ut_define.h"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC static int32_t _sd_single_read(SDHNDL *hndl, uint8_t *buff, uint32_t psn, int32_t mode);
+
+/**********************************************************************************************************************
+ * Function Name: esd_read_sect
+ * Description  : read sector data from physical sector number (=psn) by the
+ *              : number of sectors (=cnt)
+ *              : if SD Driver mode is SD_MODE_SW, data transfer by
+ *              : esddev_read_data function
+ *              : if SD Driver mode is SD_MODE_DMA, data transfer by DMAC.
+ * Arguments    : uint8_t *buff : read data buffer
+ *              : uint32_t psn : read physical sector number
+ *              : uint32_t cnt : number of read sectors.
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error.
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_read_sect(uint8_t *buff, uint32_t psn, int32_t cnt)
+{
+
+    SDHNDL *p_hndl;
+    int32_t i;
+    int32_t j;
+    int32_t ret;
+    int32_t mode = 0;
+    int32_t mmc_lastsect = 0;
+    uint16_t info1_back;
+    uint16_t ext_cd_back;
+    uint16_t ext_dat3_back;
+    uint16_t opt_back;
+
+    p_hndl = _sd_get_hndl();
+    if (p_hndl == 0)
+    {
+        return SD_ERR; /* Not initialized */
+    }
+
+    /* ---- Check card is mounted ---- */
+    if ( !p_hndl->mount)
+    {
+        _sd_set_err(p_hndl, SD_ERR);
+        return p_hndl->error; /* Not mounted yet */
+    }
+
+    p_hndl->error = SD_OK;
+
+    /* ---- Is stop compulsory? ---- */
+    if (p_hndl->stop)
+    {
+        p_hndl->stop = 0;
+        _sd_set_err(p_hndl, SD_ERR_STOP);
+        return SD_ERR_STOP;
+    }
+
+    /* ---- Is card existed? ---- */
+    if (_sd_check_media(p_hndl) != SD_OK)
+    {
+        _sd_set_err(p_hndl, SD_ERR_NO_CARD); /* No card */
+        return SD_ERR_NO_CARD;
+    }
+
+    /* Access area check */
+    if ((psn >= p_hndl->card_sector_size) || ((psn + cnt) > p_hndl->card_sector_size))
+    {
+        _sd_set_err(p_hndl, SD_ERR);
+        return p_hndl->error; /* Out of area */
+    }
+
+    /* If DMA transfer, buffer boundary is quadlet unit */
+    if ((p_hndl->trans_mode & SD_MODE_DMA) && (((uintptr_t) buff & 0x03u) == 0))
+    {
+        mode = SD_MODE_DMA; /* Set DMA mode */
+    }
+
+    /* Transfer size is fixed (512 bytes) */
+    sd_outp(p_hndl, SD_SIZE, 512);
+
+    /* ==== Check status precede read operation ==== */
+    if (_sd_card_send_cmd_arg(p_hndl, CMD13, SD_RESP_R1, p_hndl->rca[0], 0x0000)
+            == SD_OK)
+    {
+        if ((p_hndl->resp_status & RES_STATE) != STATE_TRAN)
+        { /* Not transfer state */
+#if    1
+            p_hndl->error = SD_ERR;
+#endif
+            goto ErrExit;
+        }
+    }
+    else
+    { /* SDHI error */
+        goto ErrExit;
+    }
+
+    /* ==== Execute multiple transfer by 256 sectors ==== */
+    for (i = cnt; i > 0;
+            i -= TRANS_SECTORS, psn += TRANS_SECTORS, buff += (TRANS_SECTORS * 512))
+    {
+
+        /* ---- Is card existed? ---- */
+        if (_sd_check_media(p_hndl) != SD_OK)
+        {
+            _sd_set_err(p_hndl, SD_ERR_NO_CARD); /* No card */
+            goto ErrExit;
+        }
+
+        /* Set transfer sector numbers to SD_SECCNT */
+        cnt = i - TRANS_SECTORS;
+        if (cnt < 0)
+        { /* Remaining sectors are less than TRANS_SECTORS */
+            cnt = i;
+        }
+        else
+        {
+            cnt = TRANS_SECTORS;
+        }
+
+        if (cnt <= 2)
+        {
+            /* Disable SD_SECCNT */
+            sd_outp(p_hndl, SD_STOP, 0x0000);
+            for (j = cnt; j > 0; j--, psn++, buff += 512)
+            {
+                ret = _sd_single_read(p_hndl, buff, psn, mode);
+                if (ret != SD_OK)
+                {
+                    opt_back = sd_inp(p_hndl, SD_OPTION);
+                    sd_outp(p_hndl, SOFT_RST, 0);
+                    sd_outp(p_hndl, SOFT_RST, 1);
+                    sd_outp(p_hndl, SD_OPTION, opt_back);
+
+                    /* 2010.03.19 Countermeasures for the problem that the clock is initialized after reset */
+                    /* ---- Supply clock (data-transfer ratio) ---- */
+                    if (_sd_set_clock(p_hndl, (int) p_hndl->csd_tran_speed, SD_CLOCK_ENABLE) != SD_OK)
+                    {
+                        return p_hndl->error;
+                    }
+
+                    break;
+                }
+            }
+            return p_hndl->error;
+        }
+
+        /* Enable SD_SECCNT */
+        sd_outp(p_hndl, SD_STOP, 0x0100);
+
+        /* Issue CMD12 not automatically, if MMC last sector access */
+        mmc_lastsect = 0;
+        if ((p_hndl->media_type == SD_MEDIA_MMC) && (p_hndl->card_sector_size == (psn + cnt)))
+        {
+            mmc_lastsect = 1;
+        }
+
+        sd_outp(p_hndl, SD_SECCNT, (uint16_t )cnt);
+
+        /* ---- Enable RespEnd and ILA ---- */
+        _sd_set_int_mask(p_hndl, SD_INFO1_MASK_RESP, 0);
+
+        if (mode == SD_MODE_DMA)
+        { /* ==== DMA ==== */
+            sd_set_fifo(p_hndl,0x0000); /* Disable FIFO */
+
+            /* ---- Initialize DMAC ---- */
+            if (esddev_init_dma((uintptr_t) buff, p_hndl->reg_base + SD_BUF0,
+                    cnt * 512, SD_TRANS_READ) != SD_OK)
+            {
+                _sd_set_err(p_hndl, SD_ERR_CPU_IF);
+                goto ErrExit;
+            }
+            sd_outp(p_hndl, CC_EXT_MODE, (uint16_t)(sd_inp(p_hndl,CC_EXT_MODE) | CC_EXT_MODE_DMASDRW)); /* enable DMA */
+        }
+
+        /* Issue CMD18 (READ_MULTIPLE_BLOCK) */
+        if (mmc_lastsect)
+        { /* MMC last sector access */
+            if (_sd_send_mcmd(p_hndl, CMD18 | 0x7c00u, SET_ACC_ADDR) != SD_OK)
+            {
+                goto ErrExit_DMA;
+            }
+        }
+        else
+        {
+            if (_sd_send_mcmd(p_hndl, CMD18, SET_ACC_ADDR) != SD_OK)
+            {
+                goto ErrExit_DMA;
+            }
+        }
+
+        /* ---- Disable RespEnd and ILA ---- */
+        _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_RESP, SD_INFO2_MASK_ILA);
+
+        if (mode == SD_MODE_SW)
+        { /* ==== PIO ==== */
+            /* Enable All end, BRE and errors */
+            _sd_set_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, SD_INFO2_MASK_BRE);
+            /* Software data transfer */
+            ret = _sd_software_trans(p_hndl, buff, cnt, SD_TRANS_READ);
+        }
+        else
+        { /* ==== DMA ==== */
+            /* Disable card ins&rem interrupt for FIFO */
+            info1_back = (uint16_t) (_sd_get_hndls(0)->int_info1_mask
+                    & SD_INFO1_MASK_DET_CD);
+            _sd_clear_int_mask(_sd_get_hndls(0), SD_INFO1_MASK_DET_CD, 0);
+            ext_cd_back = sd_inp(p_hndl, EXT_CD_MASK);
+            ext_dat3_back = sd_inp(p_hndl, EXT_CD_DAT3_MASK);
+            sd_outp(p_hndl, EXT_CD_MASK, 0x00ff); /* Disable all interrupt */
+            sd_outp(p_hndl, EXT_CD_DAT3_MASK, 0x00ff); /* Disable all interrupt */
+
+            /* Enable All end and errors */
+            _sd_set_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, SD_INFO2_MASK_ERR);
+            sd_set_fifo(p_hndl,0x0002); /* Disable FIFO */
+
+            /* DMA data transfer */
+            ret = _sd_dma_trans(p_hndl, cnt);
+
+            sd_outp(p_hndl, CC_EXT_MODE, (uint16_t)(sd_inp(p_hndl,CC_EXT_MODE) & ~CC_EXT_MODE_DMASDRW));
+            sd_set_fifo(p_hndl,0x0000); /* Disable FIFO */
+            _sd_set_int_mask(p_hndl, info1_back, 0);
+            sd_outp(p_hndl, EXT_CD_MASK, ext_cd_back);
+            sd_outp(p_hndl, EXT_CD_DAT3_MASK, ext_dat3_back);
+
+        }
+
+        if (ret != SD_OK)
+        {
+            goto ErrExit;
+        }
+        /* ---- Wait All end interrupt ---- */
+        if (esddev_int_wait(SD_TIMEOUT_RESP) != SD_OK)
+        {
+            _sd_set_err(p_hndl, SD_ERR_HOST_TOE);
+            goto ErrExit;
+        }
+        /* ---- Check errors ---- */
+        if (p_hndl->int_info2 & SD_INFO2_MASK_ERR)
+        {
+            _sd_check_info2_err(p_hndl);
+            goto ErrExit;
+        }
+
+        /* Clear All end bit */
+        _sd_clear_info(p_hndl, SD_INFO1_MASK_DATA_TRNS, 0x0000);
+
+        /* Disable All end, BRE and errors */
+        _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, SD_INFO2_MASK_BRE);
+
+        if (mmc_lastsect)
+        {
+            if (_sd_card_send_cmd(p_hndl,12,SD_RESP_R1b) != SD_OK)
+            {
+                /* Check OUT_OF_RANGE error */
+                /* Ignore errors during last block access */
+                if (p_hndl->resp_status & 0xffffe008ul)
+                {
+                    if ((psn + cnt) != p_hndl->card_sector_size)
+                    {
+                        goto ErrExit;
+                        /* But for last block */
+                    }
+                    if (p_hndl->resp_status & 0x7fffe008ul)
+                    {
+                        goto ErrExit;
+                        /* Not OUT_OF_RANGE error */
+                    }
+                    /* Clear OUT_OF_RANGE error */
+                    p_hndl->resp_status &= 0x1f00u;
+                    p_hndl->error = SD_OK;
+                }
+                else
+                { /* SDHI error, ex)Timeout error so on */
+                    goto ErrExit;
+                }
+            }
+        }
+
+        /* ==== Check status after read operation ==== */
+        if (_sd_card_send_cmd_arg(p_hndl, CMD13, SD_RESP_R1, p_hndl->rca[0], 0x0000)
+                != SD_OK)
+        {
+            /* Check OUT_OF_RANGE error */
+            /* Ignore errors during last block access */
+            if (p_hndl->resp_status & 0xffffe008ul)
+            {
+                if ((psn + cnt) != p_hndl->card_sector_size)
+                {
+                    goto ErrExit;
+                    /* But for last block */
+                }
+                if (p_hndl->resp_status & 0x7fffe008ul)
+                {
+                    goto ErrExit;
+                    /* Not OUT_OF_RANGE error */
+                }
+                /* Clear OUT_OF_RANGE error */
+                p_hndl->resp_status &= 0x1f00u;
+                p_hndl->error = SD_OK;
+            }
+            else
+            { /* SDHI error, ex)Timeout error so on */
+                goto ErrExit;
+            }
+        }
+
+        if ((p_hndl->resp_status & RES_STATE) != STATE_TRAN)
+        {
+#if    1
+            p_hndl->error = SD_ERR;
+#endif
+            goto ErrExit;
+        }
+
+        /* ---- Is stop compulsory? ---- */
+        if (p_hndl->stop)
+        {
+            p_hndl->stop = 0;
+            /* Data transfer stop (issue CMD12) */
+            sd_outp(p_hndl, SD_STOP, 0x0001);
+            i = 0; /* Set zero to break loop */
+            _sd_set_err(p_hndl, SD_ERR_STOP);
+        }
+    }
+
+    return p_hndl->error;
+
+ErrExit_DMA :
+    if (mode == SD_MODE_DMA)
+    {
+        esddev_disable_dma(); /* Disable DMA */
+    }
+
+ErrExit :
+    sd_outp(p_hndl, CC_EXT_MODE, (uint16_t)(sd_inp(p_hndl,CC_EXT_MODE)
+            & ~CC_EXT_MODE_DMASDRW)); /* Disable DMA */
+
+    sd_set_fifo(p_hndl,0x0000); /* Disable FIFO */
+
+    mode = p_hndl->error;
+
+    /* ---- Clear error bits ---- */
+    _sd_clear_info(p_hndl, SD_INFO1_MASK_TRNS_RESP, 0x837f);
+    /* ---- Disable all interrupts ---- */
+    _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_TRNS_RESP, 0x837f);
+
+    /* If the command sequence is being executed, stop the data transfer */
+    if ((sd_inp(p_hndl,SD_INFO2) & SD_INFO2_MASK_CBSY) == SD_INFO2_MASK_CBSY)
+    {
+        uint16_t sd_option;
+        uint16_t sd_clk_ctrl;
+
+        /* ---- Enable All end ---- */
+        _sd_set_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, 0);
+        /* ---- Data transfer stop (issue CMD12) ---- */
+        sd_outp(p_hndl, SD_STOP, 0x0001);
+        /* ---- Wait All end ---- */
+        esddev_int_wait(SD_TIMEOUT_RESP);
+        _sd_clear_info(p_hndl, SD_INFO1_MASK_TRNS_RESP, 0x837f);
+        _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, 0);
+
+        esddev_loc_cpu();
+        sd_option = sd_inp(p_hndl, SD_OPTION);
+        sd_clk_ctrl = sd_inp(p_hndl, SD_CLK_CTRL);
+        sd_outp(p_hndl, SOFT_RST, 0);
+        sd_outp(p_hndl, SOFT_RST, 1);
+        sd_outp(p_hndl, SD_STOP, 0x0000);
+        sd_outp(p_hndl, SD_OPTION, sd_option);
+        sd_outp(p_hndl, SD_CLK_CTRL, sd_clk_ctrl);
+        esddev_unl_cpu();
+    }
+
+    /* Check CURRENT_STATE */
+    if (_sd_card_send_cmd_arg(p_hndl, CMD13, SD_RESP_R1, p_hndl->rca[0], 0x0000) == SD_OK)
+    {
+        /* Not transfer state? */
+        if ((p_hndl->resp_status & RES_STATE) != STATE_TRAN)
+        {
+            /* If not transfer state, issue CMD12 and migrate to transfer state*/
+            _sd_card_send_cmd_arg(p_hndl, CMD12, SD_RESP_R1b, p_hndl->rca[0], 0x0000);
+            /* Do not check CMD12 error because it is already an error */
+        }
+    }
+
+    p_hndl->error = mode;
+
+    _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_TRNS_RESP, 0x837f);
+
+    return p_hndl->error;
+
+}
+/**********************************************************************************************************************
+ * End of function esd_read_sect
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_single_read
+ * Description  : read sector data from physical sector number (=psn) by the
+ *              : single block transfer
+ *              : if SD Driver mode is SD_MODE_SW, data transfer by
+ *              : esddev_read_data function
+ *              : if SD Driver mode is SD_MODE_DMA, data transfer by DMAC.
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint8_t *buff : read data buffer
+ *              : uint32_t psn : read physical sector number
+ *              : int32_t mode : data transfer mode
+ *              :   SD_MODE_SW : software
+ *              :   SD_MODE_DMA : DMA.
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC
+static int32_t _sd_single_read(SDHNDL *p_hndl, uint8_t *buff, uint32_t psn,
+        int32_t mode)
+{
+    int32_t ret;
+    int32_t error;
+    uint16_t info1_back;
+    uint16_t ext_cd_back;
+    uint16_t ext_dat3_back;
+
+    /* ---- Enable RespEnd and ILA ---- */
+    _sd_set_int_mask(p_hndl, SD_INFO1_MASK_RESP, SD_INFO2_MASK_ILA);
+
+    if (mode == SD_MODE_DMA)
+    { /* ==== DMA ==== */
+
+        sd_set_fifo(p_hndl,0x0000); /* Disable FIFO */
+        /* ---- Initialize DMAC ---- */
+        if (esddev_init_dma((uintptr_t) buff, (uintptr_t) p_hndl->reg_base + SD_BUF0, 512, SD_TRANS_READ) != SD_OK)
+        {
+            _sd_set_err(p_hndl, SD_ERR_CPU_IF);
+            goto ErrExit;
+        }
+
+        sd_outp(p_hndl, CC_EXT_MODE, 2); /* Enable DMA */
+    }
+
+    /* Issue CMD17 (READ_SINGLE_BLOCK) */
+
+    if (_sd_send_mcmd(p_hndl, CMD17, SET_ACC_ADDR) != SD_OK)
+    {
+
+        goto ErrExit_DMA;
+    }
+
+    /* ---- Disable RespEnd and ILA ---- */
+    _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_RESP, SD_INFO2_MASK_ILA);
+
+    if (mode == SD_MODE_SW)
+    { /* ==== PIO ==== */
+        /* Enable All end, BRE and errors */
+        _sd_set_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, SD_INFO2_MASK_BRE);
+        /* Software data transfer */
+        ret = _sd_software_trans(p_hndl, buff, 1, SD_TRANS_READ);
+    }
+    else
+    { /* ==== DMA ==== */
+        /* Disable card ins&rem interrupt for FIFO */
+        info1_back = (uint16_t) (_sd_get_hndls(0)->int_info1_mask
+                & SD_INFO1_MASK_DET_CD);
+        _sd_clear_int_mask(_sd_get_hndls(0), SD_INFO1_MASK_DET_CD, 0);
+        ext_cd_back = sd_inp(p_hndl, EXT_CD_MASK);
+        ext_dat3_back = sd_inp(p_hndl, EXT_CD_DAT3_MASK);
+        sd_outp(p_hndl, EXT_CD_MASK, 0x00ff); /* Disable all interrupt */
+        sd_outp(p_hndl, EXT_CD_DAT3_MASK, 0x00ff); /* Disable all interrupt */
+
+        /* Enable All end and errors */
+        _sd_set_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, SD_INFO2_MASK_ERR);
+        sd_set_fifo(p_hndl,0x0002); /* Disable FIFO */
+
+        /* esddev_int_wait(10); */
+        /* DMA data transfer */
+        ret = _sd_dma_trans(p_hndl, 1);
+
+        sd_outp(p_hndl, CC_EXT_MODE, (uint16_t)(sd_inp(p_hndl,CC_EXT_MODE) &
+                ~CC_EXT_MODE_DMASDRW));
+
+        sd_set_fifo(p_hndl,0x0000); /* Disable FIFO */
+        _sd_set_int_mask(p_hndl, info1_back, 0);
+        sd_outp(p_hndl, EXT_CD_MASK, ext_cd_back);
+        sd_outp(p_hndl, EXT_CD_DAT3_MASK, ext_dat3_back);
+    }
+
+    if (ret != SD_OK)
+    {
+        goto ErrExit;
+    }
+    /* ---- Wait All end interrupt ---- */
+    if (esddev_int_wait(SD_TIMEOUT_RESP) != SD_OK)
+    {
+        _sd_set_err(p_hndl, SD_ERR_HOST_TOE);
+        goto ErrExit;
+    }
+
+    /* ---- Check errors ---- */
+    if (p_hndl->int_info2 & SD_INFO2_MASK_ERR)
+    {
+        _sd_check_info2_err(p_hndl);
+        goto ErrExit;
+    }
+
+    /* Clear All end bit */
+    _sd_clear_info(p_hndl, SD_INFO1_MASK_DATA_TRNS, 0x0000);
+
+    /* Disable All end, BRE and errors */
+    _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, SD_INFO2_MASK_BRE);
+
+    /* ==== Check status after read operation ==== */
+    if (_sd_card_send_cmd_arg(p_hndl, CMD13, SD_RESP_R1, p_hndl->rca[0], 0x0000) != SD_OK)
+    {
+        /* Check OUT_OF_RANGE error */
+        /* Ignore errors during last block access */
+        if (p_hndl->resp_status & 0xffffe008ul)
+        {
+            if ((psn + 1) != p_hndl->card_sector_size)
+            {
+                goto ErrExit;
+                /* But for last block */
+            }
+            if (p_hndl->resp_status & 0x7fffe008ul)
+            {
+                goto ErrExit;
+                /* Not OUT_OF_RANGE error */
+            }
+            /* Clear OUT_OF_RANGE error */
+            p_hndl->resp_status &= 0x1f00u;
+            p_hndl->error = SD_OK;
+        }
+        else
+        { /* SDHI error, ex)Timeout error so on */
+            goto ErrExit;
+        }
+    }
+
+    return p_hndl->error;
+
+ErrExit_DMA :
+    if (mode == SD_MODE_DMA)
+    {
+        esddev_disable_dma(); /* Disable DMA */
+    }
+
+ErrExit :
+    error = p_hndl->error;
+    _sd_clear_info(p_hndl, SD_INFO1_MASK_TRNS_RESP, 0x837f);
+    _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_TRNS_RESP, 0x837f);
+    _sd_set_int_mask(p_hndl, SD_INFO1_MASK_DATA_TRNS, 0);
+    _sd_card_send_cmd_arg(p_hndl, CMD13, SD_RESP_R1, p_hndl->rca[0], 0x0000);
+    _sd_clear_int_mask(p_hndl, SD_INFO1_MASK_TRNS_RESP, 0x837f);
+    p_hndl->error = error;
+
+    return p_hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_single_read
+ *********************************************************************************************************************/
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_trns.c b/plat/renesas/rz/common/drivers/sd/sd_trns.c
new file mode 100644
index 000000000..074d0de54
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_trns.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_trans.c
+ * Version      : 1.0
+ * Description  : Data transfer.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"
+#include "sys_sel.h"
+#include "sd.h"
+#include "ut_define.h"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_software_trans
+ * Description  : transfer data to/from card by software
+ *              : this operations are used multiple command data phase
+ *              : if dir is SD_TRANS_READ, data is from card to host
+ *              : if dir is SD_TRANS_WRITE, data is from host to card.
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint8_t *buff : destination/source data buffer
+ *              : uint32_t cnt : number of transfer bytes
+ *              : int32_t dir : transfer direction.
+ * Return Value : hndl->error : SD handle error value
+ *              : SD_OK : end of succeed
+ *              : SD_ERR: end of error.
+ * Remark       : transfer finished, check CMD12 sequence refer to All end
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_software_trans(SDHNDL *hndl, uint8_t *buff, uint32_t cnt, int32_t dir)
+{
+    int32_t j;
+    int32_t (*func)(uint8_t * arg1, uintptr_t arg2, uint32_t arg3);
+
+    if (dir == SD_TRANS_READ)
+    {
+        func = esddev_read_data;
+    }
+    else
+    {
+        func = esddev_write_data;
+    }
+
+    for (j = cnt; j > 0; j--)
+    {
+        /* ---- Wait BWE/BRE interrupt ---- */
+        if (esddev_int_wait(SD_TIMEOUT_MULTIPLE) != SD_OK)
+        {
+            _sd_set_err(hndl, SD_ERR_HOST_TOE);
+            break;
+        }
+
+        if (hndl->int_info2 & SD_INFO2_MASK_ERR)
+        {
+            _sd_check_info2_err(hndl);
+            break;
+        }
+        if (dir == SD_TRANS_READ)
+        {
+            _sd_clear_info(hndl, 0x0000, SD_INFO2_MASK_RE); /* Clear BRE and errors bit */
+        }
+        else
+        {
+            _sd_clear_info(hndl, 0x0000, SD_INFO2_MASK_WE); /* Clear BWE and errors bit */
+        }
+
+        /* Write/read to/from SD_BUF by 1 sector */
+        if (( *func)(buff, (uintptr_t) hndl->reg_base + SD_BUF0, 512) != SD_OK)
+        {
+            _sd_set_err(hndl, SD_ERR_CPU_IF);
+            break;
+        }
+
+        /* Update buffer */
+        buff += 512;
+
+    }
+
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_software_trans
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_dma_trans
+ * Description  : transfer data to/from card by DMA
+ *              : this operations are multiple command data phas.
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint32_t cnt : number of transfer bytes.
+ * Return Value : hndl->error : SD handle error value
+ *              : SD_OK : end of succeed
+ *              : SD_ERR: end of error.
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_dma_trans(SDHNDL *hndl, uint32_t cnt)
+{
+    /* ---- Check DMA transfer end  --- */
+    /* Timeout value is depend on transfer size */
+    if (esddev_wait_dma_end(cnt * 512) != SD_OK)
+    {
+        esddev_disable_dma(); /* Disable DMAC */
+        _sd_set_err(hndl, SD_ERR_CPU_IF);
+        goto ErrExit;
+    }
+
+    /* ---- Disable DMAC ---- */
+    if (esddev_disable_dma() != SD_OK)
+    {
+        _sd_set_err(hndl, SD_ERR_CPU_IF);
+        goto ErrExit;
+    }
+
+ErrExit :
+    return hndl->error;
+}
+/**********************************************************************************************************************
+ * End of function _sd_dma_trans
+ *********************************************************************************************************************/
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sd_util.c b/plat/renesas/rz/common/drivers/sd/sd_util.c
new file mode 100644
index 000000000..5e98748d7
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sd_util.c
@@ -0,0 +1,400 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sd_util.c
+ * Version      : 1.0
+ * Description  : Function setting.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+#include <stdint.h>
+#include "esdif.h"
+#include "sys_sel.h"
+#include "sd.h"
+#include "ut_define.h"
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Local Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Private (static) variables and functions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_set_clock
+ * Description  : supply or halt SD clock
+ *              : if enable is SD_CLOCK_ENABLE, supply SD clock
+ *              : if enable is SD_CLOCK_DISKABLE, halt SD clock.
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : int32_t clock : SD clock frequency
+ *              : int32_t enable : supply or halt SD clock.
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error.
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_set_clock(SDHNDL *hndl, int32_t clock, int32_t enable)
+{
+    uint32_t div;
+
+    if (enable == SD_CLOCK_ENABLE)
+    {
+        /* Convert clock frequency to clock divide ratio */
+        div = esddev_get_clockdiv(clock);
+
+        if (div > SD_DIV_512)
+        {
+            _sd_set_err(hndl, SD_ERR_CPU_IF);
+            return SD_ERR;
+        }
+
+        sd_outp(hndl, SD_CLK_CTRL, (uint16_t )(div | 0x0100u));
+    }
+    else
+    {
+        if ((sd_inp(hndl,SD_INFO2) & SD_INFO2_MASK_CBSY) == SD_INFO2_MASK_CBSY)
+        {
+            /* For internal error detail    */
+            hndl->error = SD_ERR_CBSY_ERROR;
+
+        }
+        sd_outp(hndl, SD_CLK_CTRL, 0); /* Halt */
+
+    }
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_set_clock
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_set_port
+ * Description  : change data bus width
+ *              : if port is SD_PORT_SERIAL, set data bus width 1bit
+ *              : if port is SD_PORT_PARALEL, set data bus width 4bits
+ *              : change between 1bit and 4bits by ACMD6.
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : int32_t port : setting bus with.
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error.
+ * Remark       : before execute this function, check card supporting bus width
+ *              : SD memory card is 4bits support mandatory
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_set_port(SDHNDL *hndl, int32_t port)
+{
+    uint16_t reg;
+    uint16_t arg;
+
+    if (hndl->media_type & SD_MEDIA_SD)
+    { /* SD or COMBO */
+        /* ---- Check card state ---- */
+        if ((hndl->resp_status & RES_STATE) == STATE_TRAN)
+        { /* transfer state */
+            if (port == SD_PORT_SERIAL)
+            {
+                arg = ARG_ACMD6_1bit;
+            }
+            else
+            {
+                arg = ARG_ACMD6_4bit;
+            }
+            /* ==== Change card bus width (issue ACMD6) ==== */
+            if (_sd_send_acmd(hndl, ACMD6, 0, arg) != SD_OK)
+            {
+                return SD_ERR;
+            }
+            if (_sd_get_resp(hndl, SD_RESP_R1) != SD_OK)
+            {
+                return SD_ERR;
+            }
+        }
+    }
+
+    /* ==== Change SDHI bus width ==== */
+    if (port == SD_PORT_SERIAL)
+    { /* 1bit */
+        esddev_set_port(port);
+        reg = sd_inp(hndl, SD_OPTION);
+        reg |= 0x8000u;
+        sd_outp(hndl, SD_OPTION, reg);
+    }
+    else
+    { /* 4bits */
+        reg = sd_inp(hndl, SD_OPTION);
+        reg &= 0x7fffu;
+        sd_outp(hndl, SD_OPTION, reg);
+        esddev_set_port(port);
+    }
+
+    hndl->if_mode = (uint8_t) port;
+
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_set_port
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_iswp
+ * Description  : check hardware write protect refer to SDHI register
+ *              : if WP pin is disconnected to SDHI, return value has no meaning.
+ * Arguments    : SDHNDL *hndl : SD handle
+ * Return Value : SD_WP_OFF (0): write protected
+ *              : SD_WP_HW (1): not write protected
+ * Remark       : don't check CSD write protect bits and ROM card
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_iswp(SDHNDL *hndl)
+{
+    int32_t wp;
+
+    if (hndl->port == 0)
+    {
+        /* ===== Check SD_INFO1 WP bit ==== */
+        wp = ( (~sd_inp(hndl, SD_INFO1)) & 0x0080u) >> 7;
+    }
+    else
+    {
+        wp = ~(sd_inp(hndl, EXT_WP));
+        wp >>= (hndl->port - 1); /* Bit sift to b0 (sift 2,1,0bit)*/
+        wp &= 0x0001;
+    }
+
+    return wp;
+}
+/**********************************************************************************************************************
+ * End of function _sd_iswp
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_bit_search
+ * Description  : check every bits of argument (data) from LSB
+ *              : return first bit whose value is 1'b
+ *              : bit number is big endian (MSB is 0).
+ * Arguments    : uint16_t data : checked data
+ * Return Value : not less than 0 : bit number has 1'b
+ *              : -1 : no bit has 1'b
+ * Remark       : just 16bits value can be applied
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_bit_search(uint16_t data)
+{
+    int32_t i;
+
+    for (i = 15; i >= 0; i--)
+    {
+        if (data & 1u)
+        {
+            return i;
+        }
+        data >>= 1;
+    }
+
+    return -1;
+}
+/**********************************************************************************************************************
+ * End of function _sd_bit_search
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_set_err
+ * Description  : set error information (=error) to SD Handle member (=hndl->error).
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : int32_t error : setting error information
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : if hndl->error was already set, no overwrite it
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_set_err(SDHNDL *hndl, int32_t error)
+{
+    if (hndl->error == SD_OK)
+    {
+        hndl->error = error;
+    }
+
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_set_err
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esd_get_type
+ * Description  : get mounting card type, current and supported speed mode
+ *              : and capacity type
+ *              : (if SD memory card)
+ *              : following card types are defined
+ *              : SD_MEDIA_UNKNOWN : unknown media
+ *              : SD_MEDIA_MMC : MMC card
+ *              : SD_MEDIA_SD : SD Memory card
+ *              : SD_MEDIA_IO : SD IO card (IO spec ver1.10)
+ *              : SD_MEDIA_COMBO : SD COMBO card (IO spec ver1.10)
+ * Arguments    : uint16_t *type : mounting card type
+ *              : uint8_t *speed : speed mode
+ *              :   supported speed is bit4, current speed is bit0
+ *              : uint8_t *speed : speed mode
+ *              :   Standard capacity:0, High capacity:1
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : if pointer has NULL ,the value isn't returned
+ *              : only SD memory card, speed mode has meaning
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_get_type(uint16_t *type, uint8_t *speed, uint8_t *capa)
+{
+    SDHNDL *p_hndl;
+
+    p_hndl = _sd_get_hndl();
+    if (p_hndl == 0)
+    {
+        return SD_ERR; /* Not initialized */
+    }
+
+    if (type)
+    {
+        *type = (uint16_t) p_hndl->media_type;
+    }
+    else
+    {
+        return SD_ERR;
+    }
+    if (p_hndl->partition_id > 0)
+    {
+        (*type) |= SD_MEDIA_EMBEDDED;
+    }
+    if (speed)
+    {
+        *speed = p_hndl->speed_mode;
+    }
+    if (capa)
+    {
+        *capa = p_hndl->csd_structure;
+    }
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function esd_get_type
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: _sd_get_size
+ * Description  : get memory card size
+ * Arguments    : SDHNDL *hndl : SD handle
+ *              : uint32_t area : memory area (bit0:user area, bit1:protect area)
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : protect area is just the number of all sectors
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t _sd_get_size(SDHNDL *hndl, uint32_t area)
+{
+    uint32_t c_mult;
+    uint32_t c_size;
+    uint32_t read_bl_len;
+
+    /* ---- READ BL LEN ---- */
+    read_bl_len = (hndl->csd[3] & 0x0f00u) >> 8;
+
+    /* ---- C_SIZE_MULT ---- */
+    c_mult = ((hndl->csd[5] & 0x0380u) >> 7);
+
+    if (area & SD_PROT_AREA)
+    {
+        /* Calculate the number of all sectors */
+
+        if ((hndl->sup_ver == SD_MODE_VER2X) && (hndl->csd_structure == 0x01))
+        {
+            hndl->prot_sector_size = (((uint32_t) hndl->sdstatus[2] << 16u)
+                    | ((uint32_t) hndl->sdstatus[3])) / 512;
+        }
+        else
+        {
+            hndl->prot_sector_size = ((hndl->sdstatus[3] * ((uint32_t) 1 << (c_mult + 2)))
+                    * ((uint32_t) 1 << read_bl_len)) / 512;
+        }
+
+    }
+
+    if (area & SD_USER_AREA)
+    {
+        if ((hndl->sup_ver == SD_MODE_VER2X) && (hndl->csd_structure == 0x01))
+        {
+
+            c_size = ((((uint32_t) hndl->csd[4] & 0x3fffu) << 8u) |
+                    (((uint32_t) hndl->csd[5] & 0xff00u) >> 8u));
+            /* Memory capacity = C_SIZE*512K byte */
+            /* Sector_size = memory capacity/512 */
+            hndl->card_sector_size = ((c_size + 1) << 10u);
+
+        }
+        else
+        {
+            /* ---- C_SIZE ---- */
+            c_size = ((hndl->csd[3] & 0x0003u) << 10)
+                    | ((hndl->csd[4] & 0xffc0u) >> 6);
+
+            /* Calculate the number of all sectors */
+            hndl->card_sector_size = ((uint32_t) (c_size + 1) *
+                    ((uint32_t) 1 << (c_mult + 2)) * ((uint32_t) 1
+                            << read_bl_len)) / 512;
+        }
+    }
+
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function _sd_get_size
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ * Function Name: esd_set_buffer
+ * Description  : initialize SD driver work buffer
+ *              : this buffer is used for mainly MKB process
+ * Arguments    : void *buff : work buffer address
+ *              : uint32_t size : work buffer size
+ * Return Value : SD_OK : end of succeed
+ *              : SD_ERR: end of error
+ * Remark       : if applied to CPRM, allocating more than 8K bytes
+ *********************************************************************************************************************/
+SD_DRV_CODE_SEC int32_t esd_set_buffer(void *buff, uint32_t size)
+{
+    SDHNDL *p_hndl;
+
+    /* Check buffer boundary (quadlet unit) */
+    if (((uintptr_t) buff & 0x00000003u) != 0)
+    {
+        return SD_ERR;
+    }
+
+    p_hndl = _sd_get_hndl();
+    if (p_hndl == 0)
+    {
+        return SD_ERR; /* not initialized */
+    }
+
+    /* Initialize buffer area */
+    p_hndl->rw_buff = (uint8_t*) buff;
+
+    /* Initialize buffer size */
+    p_hndl->buff_size = size;
+
+    return SD_OK;
+}
+/**********************************************************************************************************************
+ * End of function esd_set_buffer
+ *********************************************************************************************************************/
+
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/sys_sel.h b/plat/renesas/rz/common/drivers/sd/sys_sel.h
new file mode 100644
index 000000000..6692f8298
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/sys_sel.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : sys_sel.h
+ * Version      : 1.0
+ * Description  : SD Driver system select option.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef SYS_SEL_H
+#define SYS_SEL_H
+
+/* #define SD_HOSTBUS32 1 */
+
+
+/* ==== Configuration ===== */
+
+    /* 16bits width */
+    
+
+/* #define __SD_DEBUG__*/        /* Debug print on */
+
+/* ==== IP selection ==== */
+/* FIFO equipped between CPU bus and SDHI data BUF */
+/* #define WITH_FIFO */
+
+/* ==== Number of ports ==== */
+#define NUM_PORT (1)
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+
+#endif /* SYS_SEL_H */
+/* End of File */
diff --git a/plat/renesas/rz/common/drivers/sd/ut_define.h b/plat/renesas/rz/common/drivers/sd/ut_define.h
new file mode 100644
index 000000000..7de310483
--- /dev/null
+++ b/plat/renesas/rz/common/drivers/sd/ut_define.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2022, Renesas Electronics Corporation. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/**********************************************************************************************************************
+ * File Name    : ut_define.h
+ * Version      : 1.0
+ * Description  : header file for ut.
+ *********************************************************************************************************************/
+/**********************************************************************************************************************
+ * History : DD.MM.YYYY Version  Description
+ *         : 01.09.2020 1.00     First Release
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Includes   <System Includes> , "Project Includes"
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Macro definitions
+ *********************************************************************************************************************/
+#ifndef INC_UT_DEFINE_H_
+#define INC_UT_DEFINE_H_
+
+#ifdef _UT_
+#define EXTERN static
+
+#define SD_DRV_CODE_SEC
+#define SD_DRV_RODATA_SEC
+#define SD_DRV_RWDATA_SEC
+#define SD_DRV_ZIDATA_SEC
+
+#define SECURE_CODE_SEC
+#define SECURE_RODATA_SEC
+#define SECURE_RWDATA_SEC
+#define SECURE_ZIDATA_SEC
+#else
+#define EXTERN extern
+
+#define SD_DRV_CODE_SEC
+#define SD_DRV_RODATA_SEC
+#define SD_DRV_RWDATA_SEC
+#define SD_DRV_ZIDATA_SEC
+
+/* define of section for secure */
+#define SECURE_CODE_SEC     __attribute__((section("CODE_SECURE")))
+#define SECURE_RODATA_SEC   __attribute__((section("CONST_SECURE")))
+#define SECURE_RWDATA_SEC   __attribute__((section("DATA_SECURE")))
+#define SECURE_ZIDATA_SEC   __attribute__((section("BSS_SECURE")))
+#endif
+
+/**********************************************************************************************************************
+ Global Typedef definitions
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ External global variables
+ *********************************************************************************************************************/
+
+/**********************************************************************************************************************
+ Exported global functions
+ *********************************************************************************************************************/
+
+#endif /* INC_UT_DEFINE_H_ */
diff --git a/plat/renesas/rz/common/include/rzg2l_def.h b/plat/renesas/rz/common/include/rzg2l_def.h
index ecb5fcde2..c9cc77209 100755
--- a/plat/renesas/rz/common/include/rzg2l_def.h
+++ b/plat/renesas/rz/common/include/rzg2l_def.h
@@ -52,6 +52,9 @@
 #define RZG2L_EMMC_FIP_BASE         (0x00020000)
 #define RZG2L_EMMC_FIP_SIZE         (0x001DFFFF)
 
+#define RZG2L_SD_FIP_BASE           (0x00010000)
+#define RZG2L_SD_FIP_SIZE           (0x001DFFFF)
+
 #define RZG2L_SYC_INCK_HZ           (24000000)
 #define RZG2L_UART_INCK_HZ          (100000000)
 #define RZG2L_UART_BARDRATE         (115200)
diff --git a/plat/renesas/rz/common/plat_storage.c b/plat/renesas/rz/common/plat_storage.c
index 04591db4e..36b8f38e3 100755
--- a/plat/renesas/rz/common/plat_storage.c
+++ b/plat/renesas/rz/common/plat_storage.c
@@ -20,9 +20,14 @@
 #include <spi_multi.h>
 #include <emmc_def.h>
 
+#include <sys_regs.h>
+#include <esdif.h>
+#include <io_sddrv.h>
+
 static uintptr_t memdrv_dev_handle;
 static uintptr_t fip_dev_handle;
 static uintptr_t emmcdrv_dev_handle;
+static uintptr_t sddrv_dev_handle;
 
 static uintptr_t boot_io_drv_id;
 
@@ -36,6 +41,11 @@ static const io_drv_spec_t emmc_block_spec = {
 	.length = RZG2L_EMMC_FIP_SIZE,
 };
 
+static const io_drv_spec_t sd_block_spec = {
+	.offset = RZG2L_SD_FIP_BASE,
+	.length = RZG2L_SD_FIP_SIZE,
+};
+
 static const io_uuid_spec_t bl31_file_spec = {
 	.uuid = UUID_EL3_RUNTIME_FIRMWARE_BL31,
 };
@@ -77,6 +87,7 @@ static const io_uuid_spec_t nt_fw_content_cert_file_spec = {
 static int32_t open_emmcdrv(const uintptr_t spec);
 static int32_t open_memmap(const uintptr_t spec);
 static int32_t open_fipdrv(const uintptr_t spec);
+static int32_t open_sddrv(const uintptr_t spec);
 
 struct plat_io_policy {
 	uintptr_t *dev_handle;
@@ -178,6 +189,52 @@ static const struct plat_io_policy emmc_policies[] = {
     { 0, 0, 0}
 };
 
+static const struct plat_io_policy sd_policies[] = {
+	[FIP_IMAGE_ID] = {
+				&sddrv_dev_handle,
+				(uintptr_t) &sd_block_spec,
+				&open_sddrv},
+	[BL31_IMAGE_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &bl31_file_spec,
+				&open_fipdrv},
+	[BL32_IMAGE_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &bl32_file_spec,
+				&open_fipdrv},
+	[BL33_IMAGE_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &bl33_file_spec,
+				&open_fipdrv},
+#if TRUSTED_BOARD_BOOT
+	[SOC_FW_KEY_CERT_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &soc_fw_key_cert_file_spec,
+				&open_fipdrv},
+	[SOC_FW_CONTENT_CERT_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &soc_fw_content_cert_file_spec,
+				&open_fipdrv},
+	[TRUSTED_OS_FW_KEY_CERT_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &tos_fw_key_cert_file_spec,
+				&open_fipdrv},
+	[TRUSTED_OS_FW_CONTENT_CERT_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &tos_fw_content_cert_file_spec,
+				&open_fipdrv},
+	[NON_TRUSTED_FW_KEY_CERT_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &nt_fw_key_cert_file_spec,
+				&open_fipdrv},
+	[NON_TRUSTED_FW_CONTENT_CERT_ID] = {
+				&fip_dev_handle,
+				(uintptr_t) &nt_fw_content_cert_file_spec,
+				&open_fipdrv},
+#endif
+    { 0, 0, 0}
+};
+
 static int32_t open_fipdrv(const uintptr_t spec)
 {
 	int32_t result;
@@ -189,6 +246,11 @@ static int32_t open_fipdrv(const uintptr_t spec)
 	return result;
 }
 
+static int32_t open_sddrv(const uintptr_t spec)
+{
+	return io_dev_init(sddrv_dev_handle, 0);
+}
+
 static int32_t open_memmap(const uintptr_t spec)
 {
 	uintptr_t handle;
@@ -215,9 +277,9 @@ void rz_io_setup(void)
 	const io_dev_connector_t *memmap;
 	const io_dev_connector_t *emmc;
 	const io_dev_connector_t *rzg2l;
-	uint16_t boot_dev;
-
-	boot_dev = *((uint16_t *)RZG2L_BOOTINFO_BASE) & MASK_BOOTM_DEVICE;
+	const io_dev_connector_t *sd;
+	
+	uint32_t stat_md_boot;
 
 	boot_io_drv_id = FIP_IMAGE_ID;
 
@@ -225,16 +287,28 @@ void rz_io_setup(void)
 
 	io_dev_open(rzg2l, 0, &fip_dev_handle);
 
-	if (boot_dev == BOOT_MODE_SPI_1_8 ||
-		boot_dev == BOOT_MODE_SPI_3_3) {
+	/* Boot Mode eSD */
+	stat_md_boot = mmio_read_32(SYS_LSI_MODE) & MASK_BOOTM_DEVICE;
+	if (stat_md_boot == BOOT_MODE_ESD){
+		if (esd_main() != SD_OK) {
+			NOTICE("BL2: Failed to eSD driver initialize.\n");
+			panic();
+		}
+		register_io_dev_sddrv(&sd);
+		io_dev_open(sd, 0, &sddrv_dev_handle);
+
+		policies = &sd_policies[0];
+	}
+	else if (stat_md_boot == BOOT_MODE_SPI_1_8 ||
+		stat_md_boot == BOOT_MODE_SPI_3_3) {
 		spi_multi_setup();
 		register_io_dev_memmap(&memmap);
 		io_dev_open(memmap, 0, &memdrv_dev_handle);
 
 		policies = &spirom_policies[0];
 	}
-	else if (boot_dev == BOOT_MODE_EMMC_1_8 ||
-		boot_dev == BOOT_MODE_EMMC_3_3) {
+	else if (stat_md_boot == BOOT_MODE_EMMC_1_8 ||
+		stat_md_boot == BOOT_MODE_EMMC_3_3) {
 		if (emmc_init() != EMMC_SUCCESS) {
 			NOTICE("BL2: Failed to eMMC driver initialize.\n");
 			panic();
diff --git a/plat/renesas/rz/common/rz_common.mk b/plat/renesas/rz/common/rz_common.mk
index dd6d51c5b..09cac1ec3 100755
--- a/plat/renesas/rz/common/rz_common.mk
+++ b/plat/renesas/rz/common/rz_common.mk
@@ -32,7 +32,8 @@ PLAT_INCLUDES		:=	-Iplat/renesas/rz/common/include								\
 						-Iplat/renesas/rz/common/drivers/io								\
 						-Idrivers/renesas/common/io										\
 						-Iplat/renesas/rz/common/include/drivers/spi_multi              \
-						-Iplat/renesas/rz/common/include/drivers/spi_multi/${SPI_FLASH}
+						-Iplat/renesas/rz/common/include/drivers/spi_multi/${SPI_FLASH}	\
+						-Iplat/renesas/rz/common/drivers/sd								\
 
 RZ_TIMER_SOURCES	:=	drivers/delay_timer/generic_delay_timer.c		\
 						drivers/delay_timer/delay_timer.c
@@ -42,6 +43,19 @@ DDR_SOURCES		:= plat/renesas/rz/common/drivers/ddr/ddr.c
 SPI_MULTI_SOURCE := plat/renesas/rz/common/drivers/spi_multi/spi_multi.c					\
 					plat/renesas/rz/common/drivers/spi_multi/${SPI_FLASH}/spi_multi_device.c
 
+SD_SOURCES		:= plat/renesas/rz/common/drivers/sd/boot_esddev.c		\
+				   plat/renesas/rz/common/drivers/sd/sd_init.c			\
+				   plat/renesas/rz/common/drivers/sd/sd_mount.c			\
+				   plat/renesas/rz/common/drivers/sd/sd_util.c			\
+				   plat/renesas/rz/common/drivers/sd/sd_cd.c			\
+				   plat/renesas/rz/common/drivers/sd/sd_cmd.c			\
+				   plat/renesas/rz/common/drivers/sd/sd_int.c			\
+				   plat/renesas/rz/common/drivers/sd/sd_trns.c			\
+				   plat/renesas/rz/common/drivers/sd/sd_read.c			\
+				   plat/renesas/rz/common/drivers/sd/sd_main.c			\
+				   plat/renesas/rz/common/drivers/io/io_sddrv.c
+
+
 BL2_SOURCES		+=	lib/cpus/aarch64/cortex_a55.S						\
 					${RZ_TIMER_SOURCES}									\
 					${DYN_CFG_SOURCES}									\
@@ -67,7 +81,8 @@ BL2_SOURCES		+=	lib/cpus/aarch64/cortex_a55.S						\
 					plat/renesas/rz/common/drivers/pfc.c				\
 					plat/renesas/rz/common/drivers/cpg.c				\
 					${DDR_SOURCES}										\
-					${SPI_MULTI_SOURCE}
+					${SPI_MULTI_SOURCE}						\
+					${SD_SOURCES}
 
 # Include GICv3 driver files
 GICV3_IMPL		:= GIC600
-- 
2.34.1

